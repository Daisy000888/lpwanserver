// Code generated by Prisma (prisma@1.32.2). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  application: (where?: ApplicationWhereInput) => Promise<boolean>;
  applicationNetworkTypeLink: (
    where?: ApplicationNetworkTypeLinkWhereInput
  ) => Promise<boolean>;
  company: (where?: CompanyWhereInput) => Promise<boolean>;
  companyNetworkTypeLink: (
    where?: CompanyNetworkTypeLinkWhereInput
  ) => Promise<boolean>;
  companyType: (where?: CompanyTypeWhereInput) => Promise<boolean>;
  device: (where?: DeviceWhereInput) => Promise<boolean>;
  deviceNetworkTypeLink: (
    where?: DeviceNetworkTypeLinkWhereInput
  ) => Promise<boolean>;
  deviceProfile: (where?: DeviceProfileWhereInput) => Promise<boolean>;
  emailVerification: (where?: EmailVerificationWhereInput) => Promise<boolean>;
  network: (where?: NetworkWhereInput) => Promise<boolean>;
  networkProtocol: (where?: NetworkProtocolWhereInput) => Promise<boolean>;
  networkProvider: (where?: NetworkProviderWhereInput) => Promise<boolean>;
  networkType: (where?: NetworkTypeWhereInput) => Promise<boolean>;
  passwordPolicy: (where?: PasswordPolicyWhereInput) => Promise<boolean>;
  protocolData: (where?: ProtocolDataWhereInput) => Promise<boolean>;
  reportingProtocol: (where?: ReportingProtocolWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  userRole: (where?: UserRoleWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  application: (
    where: ApplicationWhereUniqueInput
  ) => ApplicationNullablePromise;
  applications: (args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Application>;
  applicationsConnection: (args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ApplicationConnectionPromise;
  applicationNetworkTypeLink: (
    where: ApplicationNetworkTypeLinkWhereUniqueInput
  ) => ApplicationNetworkTypeLinkNullablePromise;
  applicationNetworkTypeLinks: (args?: {
    where?: ApplicationNetworkTypeLinkWhereInput;
    orderBy?: ApplicationNetworkTypeLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ApplicationNetworkTypeLink>;
  applicationNetworkTypeLinksConnection: (args?: {
    where?: ApplicationNetworkTypeLinkWhereInput;
    orderBy?: ApplicationNetworkTypeLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ApplicationNetworkTypeLinkConnectionPromise;
  company: (where: CompanyWhereUniqueInput) => CompanyNullablePromise;
  companies: (args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Company>;
  companiesConnection: (args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CompanyConnectionPromise;
  companyNetworkTypeLink: (
    where: CompanyNetworkTypeLinkWhereUniqueInput
  ) => CompanyNetworkTypeLinkNullablePromise;
  companyNetworkTypeLinks: (args?: {
    where?: CompanyNetworkTypeLinkWhereInput;
    orderBy?: CompanyNetworkTypeLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CompanyNetworkTypeLink>;
  companyNetworkTypeLinksConnection: (args?: {
    where?: CompanyNetworkTypeLinkWhereInput;
    orderBy?: CompanyNetworkTypeLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CompanyNetworkTypeLinkConnectionPromise;
  companyType: (
    where: CompanyTypeWhereUniqueInput
  ) => CompanyTypeNullablePromise;
  companyTypes: (args?: {
    where?: CompanyTypeWhereInput;
    orderBy?: CompanyTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CompanyType>;
  companyTypesConnection: (args?: {
    where?: CompanyTypeWhereInput;
    orderBy?: CompanyTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CompanyTypeConnectionPromise;
  device: (where: DeviceWhereUniqueInput) => DeviceNullablePromise;
  devices: (args?: {
    where?: DeviceWhereInput;
    orderBy?: DeviceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Device>;
  devicesConnection: (args?: {
    where?: DeviceWhereInput;
    orderBy?: DeviceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DeviceConnectionPromise;
  deviceNetworkTypeLink: (
    where: DeviceNetworkTypeLinkWhereUniqueInput
  ) => DeviceNetworkTypeLinkNullablePromise;
  deviceNetworkTypeLinks: (args?: {
    where?: DeviceNetworkTypeLinkWhereInput;
    orderBy?: DeviceNetworkTypeLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<DeviceNetworkTypeLink>;
  deviceNetworkTypeLinksConnection: (args?: {
    where?: DeviceNetworkTypeLinkWhereInput;
    orderBy?: DeviceNetworkTypeLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DeviceNetworkTypeLinkConnectionPromise;
  deviceProfile: (
    where: DeviceProfileWhereUniqueInput
  ) => DeviceProfileNullablePromise;
  deviceProfiles: (args?: {
    where?: DeviceProfileWhereInput;
    orderBy?: DeviceProfileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<DeviceProfile>;
  deviceProfilesConnection: (args?: {
    where?: DeviceProfileWhereInput;
    orderBy?: DeviceProfileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DeviceProfileConnectionPromise;
  emailVerification: (
    where: EmailVerificationWhereUniqueInput
  ) => EmailVerificationNullablePromise;
  emailVerifications: (args?: {
    where?: EmailVerificationWhereInput;
    orderBy?: EmailVerificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<EmailVerification>;
  emailVerificationsConnection: (args?: {
    where?: EmailVerificationWhereInput;
    orderBy?: EmailVerificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EmailVerificationConnectionPromise;
  network: (where: NetworkWhereUniqueInput) => NetworkNullablePromise;
  networks: (args?: {
    where?: NetworkWhereInput;
    orderBy?: NetworkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Network>;
  networksConnection: (args?: {
    where?: NetworkWhereInput;
    orderBy?: NetworkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => NetworkConnectionPromise;
  networkProtocol: (
    where: NetworkProtocolWhereUniqueInput
  ) => NetworkProtocolNullablePromise;
  networkProtocols: (args?: {
    where?: NetworkProtocolWhereInput;
    orderBy?: NetworkProtocolOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<NetworkProtocol>;
  networkProtocolsConnection: (args?: {
    where?: NetworkProtocolWhereInput;
    orderBy?: NetworkProtocolOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => NetworkProtocolConnectionPromise;
  networkProvider: (
    where: NetworkProviderWhereUniqueInput
  ) => NetworkProviderNullablePromise;
  networkProviders: (args?: {
    where?: NetworkProviderWhereInput;
    orderBy?: NetworkProviderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<NetworkProvider>;
  networkProvidersConnection: (args?: {
    where?: NetworkProviderWhereInput;
    orderBy?: NetworkProviderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => NetworkProviderConnectionPromise;
  networkType: (
    where: NetworkTypeWhereUniqueInput
  ) => NetworkTypeNullablePromise;
  networkTypes: (args?: {
    where?: NetworkTypeWhereInput;
    orderBy?: NetworkTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<NetworkType>;
  networkTypesConnection: (args?: {
    where?: NetworkTypeWhereInput;
    orderBy?: NetworkTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => NetworkTypeConnectionPromise;
  passwordPolicy: (
    where: PasswordPolicyWhereUniqueInput
  ) => PasswordPolicyNullablePromise;
  passwordPolicies: (args?: {
    where?: PasswordPolicyWhereInput;
    orderBy?: PasswordPolicyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PasswordPolicy>;
  passwordPoliciesConnection: (args?: {
    where?: PasswordPolicyWhereInput;
    orderBy?: PasswordPolicyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PasswordPolicyConnectionPromise;
  protocolData: (
    where: ProtocolDataWhereUniqueInput
  ) => ProtocolDataNullablePromise;
  protocolDatas: (args?: {
    where?: ProtocolDataWhereInput;
    orderBy?: ProtocolDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProtocolData>;
  protocolDatasConnection: (args?: {
    where?: ProtocolDataWhereInput;
    orderBy?: ProtocolDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProtocolDataConnectionPromise;
  reportingProtocol: (
    where: ReportingProtocolWhereUniqueInput
  ) => ReportingProtocolNullablePromise;
  reportingProtocols: (args?: {
    where?: ReportingProtocolWhereInput;
    orderBy?: ReportingProtocolOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ReportingProtocol>;
  reportingProtocolsConnection: (args?: {
    where?: ReportingProtocolWhereInput;
    orderBy?: ReportingProtocolOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ReportingProtocolConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  userRole: (where: UserRoleWhereUniqueInput) => UserRoleNullablePromise;
  userRoles: (args?: {
    where?: UserRoleWhereInput;
    orderBy?: UserRoleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<UserRole>;
  userRolesConnection: (args?: {
    where?: UserRoleWhereInput;
    orderBy?: UserRoleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserRoleConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createApplication: (data: ApplicationCreateInput) => ApplicationPromise;
  updateApplication: (args: {
    data: ApplicationUpdateInput;
    where: ApplicationWhereUniqueInput;
  }) => ApplicationPromise;
  updateManyApplications: (args: {
    data: ApplicationUpdateManyMutationInput;
    where?: ApplicationWhereInput;
  }) => BatchPayloadPromise;
  upsertApplication: (args: {
    where: ApplicationWhereUniqueInput;
    create: ApplicationCreateInput;
    update: ApplicationUpdateInput;
  }) => ApplicationPromise;
  deleteApplication: (where: ApplicationWhereUniqueInput) => ApplicationPromise;
  deleteManyApplications: (
    where?: ApplicationWhereInput
  ) => BatchPayloadPromise;
  createApplicationNetworkTypeLink: (
    data: ApplicationNetworkTypeLinkCreateInput
  ) => ApplicationNetworkTypeLinkPromise;
  updateApplicationNetworkTypeLink: (args: {
    data: ApplicationNetworkTypeLinkUpdateInput;
    where: ApplicationNetworkTypeLinkWhereUniqueInput;
  }) => ApplicationNetworkTypeLinkPromise;
  updateManyApplicationNetworkTypeLinks: (args: {
    data: ApplicationNetworkTypeLinkUpdateManyMutationInput;
    where?: ApplicationNetworkTypeLinkWhereInput;
  }) => BatchPayloadPromise;
  upsertApplicationNetworkTypeLink: (args: {
    where: ApplicationNetworkTypeLinkWhereUniqueInput;
    create: ApplicationNetworkTypeLinkCreateInput;
    update: ApplicationNetworkTypeLinkUpdateInput;
  }) => ApplicationNetworkTypeLinkPromise;
  deleteApplicationNetworkTypeLink: (
    where: ApplicationNetworkTypeLinkWhereUniqueInput
  ) => ApplicationNetworkTypeLinkPromise;
  deleteManyApplicationNetworkTypeLinks: (
    where?: ApplicationNetworkTypeLinkWhereInput
  ) => BatchPayloadPromise;
  createCompany: (data: CompanyCreateInput) => CompanyPromise;
  updateCompany: (args: {
    data: CompanyUpdateInput;
    where: CompanyWhereUniqueInput;
  }) => CompanyPromise;
  updateManyCompanies: (args: {
    data: CompanyUpdateManyMutationInput;
    where?: CompanyWhereInput;
  }) => BatchPayloadPromise;
  upsertCompany: (args: {
    where: CompanyWhereUniqueInput;
    create: CompanyCreateInput;
    update: CompanyUpdateInput;
  }) => CompanyPromise;
  deleteCompany: (where: CompanyWhereUniqueInput) => CompanyPromise;
  deleteManyCompanies: (where?: CompanyWhereInput) => BatchPayloadPromise;
  createCompanyNetworkTypeLink: (
    data: CompanyNetworkTypeLinkCreateInput
  ) => CompanyNetworkTypeLinkPromise;
  updateCompanyNetworkTypeLink: (args: {
    data: CompanyNetworkTypeLinkUpdateInput;
    where: CompanyNetworkTypeLinkWhereUniqueInput;
  }) => CompanyNetworkTypeLinkPromise;
  updateManyCompanyNetworkTypeLinks: (args: {
    data: CompanyNetworkTypeLinkUpdateManyMutationInput;
    where?: CompanyNetworkTypeLinkWhereInput;
  }) => BatchPayloadPromise;
  upsertCompanyNetworkTypeLink: (args: {
    where: CompanyNetworkTypeLinkWhereUniqueInput;
    create: CompanyNetworkTypeLinkCreateInput;
    update: CompanyNetworkTypeLinkUpdateInput;
  }) => CompanyNetworkTypeLinkPromise;
  deleteCompanyNetworkTypeLink: (
    where: CompanyNetworkTypeLinkWhereUniqueInput
  ) => CompanyNetworkTypeLinkPromise;
  deleteManyCompanyNetworkTypeLinks: (
    where?: CompanyNetworkTypeLinkWhereInput
  ) => BatchPayloadPromise;
  createCompanyType: (data: CompanyTypeCreateInput) => CompanyTypePromise;
  updateCompanyType: (args: {
    data: CompanyTypeUpdateInput;
    where: CompanyTypeWhereUniqueInput;
  }) => CompanyTypePromise;
  updateManyCompanyTypes: (args: {
    data: CompanyTypeUpdateManyMutationInput;
    where?: CompanyTypeWhereInput;
  }) => BatchPayloadPromise;
  upsertCompanyType: (args: {
    where: CompanyTypeWhereUniqueInput;
    create: CompanyTypeCreateInput;
    update: CompanyTypeUpdateInput;
  }) => CompanyTypePromise;
  deleteCompanyType: (where: CompanyTypeWhereUniqueInput) => CompanyTypePromise;
  deleteManyCompanyTypes: (
    where?: CompanyTypeWhereInput
  ) => BatchPayloadPromise;
  createDevice: (data: DeviceCreateInput) => DevicePromise;
  updateDevice: (args: {
    data: DeviceUpdateInput;
    where: DeviceWhereUniqueInput;
  }) => DevicePromise;
  updateManyDevices: (args: {
    data: DeviceUpdateManyMutationInput;
    where?: DeviceWhereInput;
  }) => BatchPayloadPromise;
  upsertDevice: (args: {
    where: DeviceWhereUniqueInput;
    create: DeviceCreateInput;
    update: DeviceUpdateInput;
  }) => DevicePromise;
  deleteDevice: (where: DeviceWhereUniqueInput) => DevicePromise;
  deleteManyDevices: (where?: DeviceWhereInput) => BatchPayloadPromise;
  createDeviceNetworkTypeLink: (
    data: DeviceNetworkTypeLinkCreateInput
  ) => DeviceNetworkTypeLinkPromise;
  updateDeviceNetworkTypeLink: (args: {
    data: DeviceNetworkTypeLinkUpdateInput;
    where: DeviceNetworkTypeLinkWhereUniqueInput;
  }) => DeviceNetworkTypeLinkPromise;
  updateManyDeviceNetworkTypeLinks: (args: {
    data: DeviceNetworkTypeLinkUpdateManyMutationInput;
    where?: DeviceNetworkTypeLinkWhereInput;
  }) => BatchPayloadPromise;
  upsertDeviceNetworkTypeLink: (args: {
    where: DeviceNetworkTypeLinkWhereUniqueInput;
    create: DeviceNetworkTypeLinkCreateInput;
    update: DeviceNetworkTypeLinkUpdateInput;
  }) => DeviceNetworkTypeLinkPromise;
  deleteDeviceNetworkTypeLink: (
    where: DeviceNetworkTypeLinkWhereUniqueInput
  ) => DeviceNetworkTypeLinkPromise;
  deleteManyDeviceNetworkTypeLinks: (
    where?: DeviceNetworkTypeLinkWhereInput
  ) => BatchPayloadPromise;
  createDeviceProfile: (data: DeviceProfileCreateInput) => DeviceProfilePromise;
  updateDeviceProfile: (args: {
    data: DeviceProfileUpdateInput;
    where: DeviceProfileWhereUniqueInput;
  }) => DeviceProfilePromise;
  updateManyDeviceProfiles: (args: {
    data: DeviceProfileUpdateManyMutationInput;
    where?: DeviceProfileWhereInput;
  }) => BatchPayloadPromise;
  upsertDeviceProfile: (args: {
    where: DeviceProfileWhereUniqueInput;
    create: DeviceProfileCreateInput;
    update: DeviceProfileUpdateInput;
  }) => DeviceProfilePromise;
  deleteDeviceProfile: (
    where: DeviceProfileWhereUniqueInput
  ) => DeviceProfilePromise;
  deleteManyDeviceProfiles: (
    where?: DeviceProfileWhereInput
  ) => BatchPayloadPromise;
  createEmailVerification: (
    data: EmailVerificationCreateInput
  ) => EmailVerificationPromise;
  updateEmailVerification: (args: {
    data: EmailVerificationUpdateInput;
    where: EmailVerificationWhereUniqueInput;
  }) => EmailVerificationPromise;
  updateManyEmailVerifications: (args: {
    data: EmailVerificationUpdateManyMutationInput;
    where?: EmailVerificationWhereInput;
  }) => BatchPayloadPromise;
  upsertEmailVerification: (args: {
    where: EmailVerificationWhereUniqueInput;
    create: EmailVerificationCreateInput;
    update: EmailVerificationUpdateInput;
  }) => EmailVerificationPromise;
  deleteEmailVerification: (
    where: EmailVerificationWhereUniqueInput
  ) => EmailVerificationPromise;
  deleteManyEmailVerifications: (
    where?: EmailVerificationWhereInput
  ) => BatchPayloadPromise;
  createNetwork: (data: NetworkCreateInput) => NetworkPromise;
  updateNetwork: (args: {
    data: NetworkUpdateInput;
    where: NetworkWhereUniqueInput;
  }) => NetworkPromise;
  updateManyNetworks: (args: {
    data: NetworkUpdateManyMutationInput;
    where?: NetworkWhereInput;
  }) => BatchPayloadPromise;
  upsertNetwork: (args: {
    where: NetworkWhereUniqueInput;
    create: NetworkCreateInput;
    update: NetworkUpdateInput;
  }) => NetworkPromise;
  deleteNetwork: (where: NetworkWhereUniqueInput) => NetworkPromise;
  deleteManyNetworks: (where?: NetworkWhereInput) => BatchPayloadPromise;
  createNetworkProtocol: (
    data: NetworkProtocolCreateInput
  ) => NetworkProtocolPromise;
  updateNetworkProtocol: (args: {
    data: NetworkProtocolUpdateInput;
    where: NetworkProtocolWhereUniqueInput;
  }) => NetworkProtocolPromise;
  updateManyNetworkProtocols: (args: {
    data: NetworkProtocolUpdateManyMutationInput;
    where?: NetworkProtocolWhereInput;
  }) => BatchPayloadPromise;
  upsertNetworkProtocol: (args: {
    where: NetworkProtocolWhereUniqueInput;
    create: NetworkProtocolCreateInput;
    update: NetworkProtocolUpdateInput;
  }) => NetworkProtocolPromise;
  deleteNetworkProtocol: (
    where: NetworkProtocolWhereUniqueInput
  ) => NetworkProtocolPromise;
  deleteManyNetworkProtocols: (
    where?: NetworkProtocolWhereInput
  ) => BatchPayloadPromise;
  createNetworkProvider: (
    data: NetworkProviderCreateInput
  ) => NetworkProviderPromise;
  updateNetworkProvider: (args: {
    data: NetworkProviderUpdateInput;
    where: NetworkProviderWhereUniqueInput;
  }) => NetworkProviderPromise;
  updateManyNetworkProviders: (args: {
    data: NetworkProviderUpdateManyMutationInput;
    where?: NetworkProviderWhereInput;
  }) => BatchPayloadPromise;
  upsertNetworkProvider: (args: {
    where: NetworkProviderWhereUniqueInput;
    create: NetworkProviderCreateInput;
    update: NetworkProviderUpdateInput;
  }) => NetworkProviderPromise;
  deleteNetworkProvider: (
    where: NetworkProviderWhereUniqueInput
  ) => NetworkProviderPromise;
  deleteManyNetworkProviders: (
    where?: NetworkProviderWhereInput
  ) => BatchPayloadPromise;
  createNetworkType: (data: NetworkTypeCreateInput) => NetworkTypePromise;
  updateNetworkType: (args: {
    data: NetworkTypeUpdateInput;
    where: NetworkTypeWhereUniqueInput;
  }) => NetworkTypePromise;
  updateManyNetworkTypes: (args: {
    data: NetworkTypeUpdateManyMutationInput;
    where?: NetworkTypeWhereInput;
  }) => BatchPayloadPromise;
  upsertNetworkType: (args: {
    where: NetworkTypeWhereUniqueInput;
    create: NetworkTypeCreateInput;
    update: NetworkTypeUpdateInput;
  }) => NetworkTypePromise;
  deleteNetworkType: (where: NetworkTypeWhereUniqueInput) => NetworkTypePromise;
  deleteManyNetworkTypes: (
    where?: NetworkTypeWhereInput
  ) => BatchPayloadPromise;
  createPasswordPolicy: (
    data: PasswordPolicyCreateInput
  ) => PasswordPolicyPromise;
  updatePasswordPolicy: (args: {
    data: PasswordPolicyUpdateInput;
    where: PasswordPolicyWhereUniqueInput;
  }) => PasswordPolicyPromise;
  updateManyPasswordPolicies: (args: {
    data: PasswordPolicyUpdateManyMutationInput;
    where?: PasswordPolicyWhereInput;
  }) => BatchPayloadPromise;
  upsertPasswordPolicy: (args: {
    where: PasswordPolicyWhereUniqueInput;
    create: PasswordPolicyCreateInput;
    update: PasswordPolicyUpdateInput;
  }) => PasswordPolicyPromise;
  deletePasswordPolicy: (
    where: PasswordPolicyWhereUniqueInput
  ) => PasswordPolicyPromise;
  deleteManyPasswordPolicies: (
    where?: PasswordPolicyWhereInput
  ) => BatchPayloadPromise;
  createProtocolData: (data: ProtocolDataCreateInput) => ProtocolDataPromise;
  updateProtocolData: (args: {
    data: ProtocolDataUpdateInput;
    where: ProtocolDataWhereUniqueInput;
  }) => ProtocolDataPromise;
  updateManyProtocolDatas: (args: {
    data: ProtocolDataUpdateManyMutationInput;
    where?: ProtocolDataWhereInput;
  }) => BatchPayloadPromise;
  upsertProtocolData: (args: {
    where: ProtocolDataWhereUniqueInput;
    create: ProtocolDataCreateInput;
    update: ProtocolDataUpdateInput;
  }) => ProtocolDataPromise;
  deleteProtocolData: (
    where: ProtocolDataWhereUniqueInput
  ) => ProtocolDataPromise;
  deleteManyProtocolDatas: (
    where?: ProtocolDataWhereInput
  ) => BatchPayloadPromise;
  createReportingProtocol: (
    data: ReportingProtocolCreateInput
  ) => ReportingProtocolPromise;
  updateReportingProtocol: (args: {
    data: ReportingProtocolUpdateInput;
    where: ReportingProtocolWhereUniqueInput;
  }) => ReportingProtocolPromise;
  updateManyReportingProtocols: (args: {
    data: ReportingProtocolUpdateManyMutationInput;
    where?: ReportingProtocolWhereInput;
  }) => BatchPayloadPromise;
  upsertReportingProtocol: (args: {
    where: ReportingProtocolWhereUniqueInput;
    create: ReportingProtocolCreateInput;
    update: ReportingProtocolUpdateInput;
  }) => ReportingProtocolPromise;
  deleteReportingProtocol: (
    where: ReportingProtocolWhereUniqueInput
  ) => ReportingProtocolPromise;
  deleteManyReportingProtocols: (
    where?: ReportingProtocolWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createUserRole: (data: UserRoleCreateInput) => UserRolePromise;
  updateUserRole: (args: {
    data: UserRoleUpdateInput;
    where: UserRoleWhereUniqueInput;
  }) => UserRolePromise;
  updateManyUserRoles: (args: {
    data: UserRoleUpdateManyMutationInput;
    where?: UserRoleWhereInput;
  }) => BatchPayloadPromise;
  upsertUserRole: (args: {
    where: UserRoleWhereUniqueInput;
    create: UserRoleCreateInput;
    update: UserRoleUpdateInput;
  }) => UserRolePromise;
  deleteUserRole: (where: UserRoleWhereUniqueInput) => UserRolePromise;
  deleteManyUserRoles: (where?: UserRoleWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  application: (
    where?: ApplicationSubscriptionWhereInput
  ) => ApplicationSubscriptionPayloadSubscription;
  applicationNetworkTypeLink: (
    where?: ApplicationNetworkTypeLinkSubscriptionWhereInput
  ) => ApplicationNetworkTypeLinkSubscriptionPayloadSubscription;
  company: (
    where?: CompanySubscriptionWhereInput
  ) => CompanySubscriptionPayloadSubscription;
  companyNetworkTypeLink: (
    where?: CompanyNetworkTypeLinkSubscriptionWhereInput
  ) => CompanyNetworkTypeLinkSubscriptionPayloadSubscription;
  companyType: (
    where?: CompanyTypeSubscriptionWhereInput
  ) => CompanyTypeSubscriptionPayloadSubscription;
  device: (
    where?: DeviceSubscriptionWhereInput
  ) => DeviceSubscriptionPayloadSubscription;
  deviceNetworkTypeLink: (
    where?: DeviceNetworkTypeLinkSubscriptionWhereInput
  ) => DeviceNetworkTypeLinkSubscriptionPayloadSubscription;
  deviceProfile: (
    where?: DeviceProfileSubscriptionWhereInput
  ) => DeviceProfileSubscriptionPayloadSubscription;
  emailVerification: (
    where?: EmailVerificationSubscriptionWhereInput
  ) => EmailVerificationSubscriptionPayloadSubscription;
  network: (
    where?: NetworkSubscriptionWhereInput
  ) => NetworkSubscriptionPayloadSubscription;
  networkProtocol: (
    where?: NetworkProtocolSubscriptionWhereInput
  ) => NetworkProtocolSubscriptionPayloadSubscription;
  networkProvider: (
    where?: NetworkProviderSubscriptionWhereInput
  ) => NetworkProviderSubscriptionPayloadSubscription;
  networkType: (
    where?: NetworkTypeSubscriptionWhereInput
  ) => NetworkTypeSubscriptionPayloadSubscription;
  passwordPolicy: (
    where?: PasswordPolicySubscriptionWhereInput
  ) => PasswordPolicySubscriptionPayloadSubscription;
  protocolData: (
    where?: ProtocolDataSubscriptionWhereInput
  ) => ProtocolDataSubscriptionPayloadSubscription;
  reportingProtocol: (
    where?: ReportingProtocolSubscriptionWhereInput
  ) => ReportingProtocolSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  userRole: (
    where?: UserRoleSubscriptionWhereInput
  ) => UserRoleSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type PasswordPolicyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "ruleText_ASC"
  | "ruleText_DESC"
  | "ruleRegExp_ASC"
  | "ruleRegExp_DESC";

export type CompanyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type ProtocolDataOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "dataIdentifier_ASC"
  | "dataIdentifier_DESC"
  | "dataValue_ASC"
  | "dataValue_DESC";

export type UserRoleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type NetworkOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "baseUrl_ASC"
  | "baseUrl_DESC"
  | "securityData_ASC"
  | "securityData_DESC";

export type NetworkTypeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type NetworkProtocolOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "protocolHandler_ASC"
  | "protocolHandler_DESC"
  | "networkProtocolVersion_ASC"
  | "networkProtocolVersion_DESC"
  | "masterProtocol_ASC"
  | "masterProtocol_DESC";

export type CompanyTypeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type DeviceProfileOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "networkSettings_ASC"
  | "networkSettings_DESC";

export type EmailVerificationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "uuid_ASC"
  | "uuid_DESC"
  | "email_ASC"
  | "email_DESC"
  | "changeRequested_ASC"
  | "changeRequested_DESC";

export type ApplicationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "baseUrl_ASC"
  | "baseUrl_DESC"
  | "enabled_ASC"
  | "enabled_DESC";

export type CompanyNetworkTypeLinkOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "networkSettings_ASC"
  | "networkSettings_DESC";

export type ApplicationNetworkTypeLinkOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "networkSettings_ASC"
  | "networkSettings_DESC";

export type DeviceNetworkTypeLinkOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "networkSettings_ASC"
  | "networkSettings_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "username_ASC"
  | "username_DESC"
  | "email_ASC"
  | "email_DESC"
  | "lastVerifiedEmail_ASC"
  | "lastVerifiedEmail_DESC"
  | "emailVerified_ASC"
  | "emailVerified_DESC"
  | "passwordHash_ASC"
  | "passwordHash_DESC";

export type DeviceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "deviceModel_ASC"
  | "deviceModel_DESC";

export type NetworkProviderOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type ReportingProtocolOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "protocolHandler_ASC"
  | "protocolHandler_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface NetworkUpdateManyWithoutNetworkProtocolInput {
  create?: Maybe<
    | NetworkCreateWithoutNetworkProtocolInput[]
    | NetworkCreateWithoutNetworkProtocolInput
  >;
  delete?: Maybe<NetworkWhereUniqueInput[] | NetworkWhereUniqueInput>;
  connect?: Maybe<NetworkWhereUniqueInput[] | NetworkWhereUniqueInput>;
  set?: Maybe<NetworkWhereUniqueInput[] | NetworkWhereUniqueInput>;
  disconnect?: Maybe<NetworkWhereUniqueInput[] | NetworkWhereUniqueInput>;
  update?: Maybe<
    | NetworkUpdateWithWhereUniqueWithoutNetworkProtocolInput[]
    | NetworkUpdateWithWhereUniqueWithoutNetworkProtocolInput
  >;
  upsert?: Maybe<
    | NetworkUpsertWithWhereUniqueWithoutNetworkProtocolInput[]
    | NetworkUpsertWithWhereUniqueWithoutNetworkProtocolInput
  >;
  deleteMany?: Maybe<NetworkScalarWhereInput[] | NetworkScalarWhereInput>;
  updateMany?: Maybe<
    | NetworkUpdateManyWithWhereNestedInput[]
    | NetworkUpdateManyWithWhereNestedInput
  >;
}

export type ApplicationWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface CompanyUpdateOneRequiredWithoutDeviceProfilesInput {
  create?: Maybe<CompanyCreateWithoutDeviceProfilesInput>;
  update?: Maybe<CompanyUpdateWithoutDeviceProfilesDataInput>;
  upsert?: Maybe<CompanyUpsertWithoutDeviceProfilesInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface PasswordPolicyWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  ruleText?: Maybe<String>;
  ruleText_not?: Maybe<String>;
  ruleText_in?: Maybe<String[] | String>;
  ruleText_not_in?: Maybe<String[] | String>;
  ruleText_lt?: Maybe<String>;
  ruleText_lte?: Maybe<String>;
  ruleText_gt?: Maybe<String>;
  ruleText_gte?: Maybe<String>;
  ruleText_contains?: Maybe<String>;
  ruleText_not_contains?: Maybe<String>;
  ruleText_starts_with?: Maybe<String>;
  ruleText_not_starts_with?: Maybe<String>;
  ruleText_ends_with?: Maybe<String>;
  ruleText_not_ends_with?: Maybe<String>;
  ruleRegExp?: Maybe<String>;
  ruleRegExp_not?: Maybe<String>;
  ruleRegExp_in?: Maybe<String[] | String>;
  ruleRegExp_not_in?: Maybe<String[] | String>;
  ruleRegExp_lt?: Maybe<String>;
  ruleRegExp_lte?: Maybe<String>;
  ruleRegExp_gt?: Maybe<String>;
  ruleRegExp_gte?: Maybe<String>;
  ruleRegExp_contains?: Maybe<String>;
  ruleRegExp_not_contains?: Maybe<String>;
  ruleRegExp_starts_with?: Maybe<String>;
  ruleRegExp_not_starts_with?: Maybe<String>;
  ruleRegExp_ends_with?: Maybe<String>;
  ruleRegExp_not_ends_with?: Maybe<String>;
  company?: Maybe<CompanyWhereInput>;
  AND?: Maybe<PasswordPolicyWhereInput[] | PasswordPolicyWhereInput>;
  OR?: Maybe<PasswordPolicyWhereInput[] | PasswordPolicyWhereInput>;
  NOT?: Maybe<PasswordPolicyWhereInput[] | PasswordPolicyWhereInput>;
}

export interface CompanyUpdateWithoutDeviceProfilesDataInput {
  name?: Maybe<String>;
  type?: Maybe<CompanyTypeUpdateOneWithoutCompaniesInput>;
  applications?: Maybe<ApplicationUpdateManyWithoutCompanyInput>;
  companyNetworkTypeLinks?: Maybe<
    CompanyNetworkTypeLinkUpdateManyWithoutCompanyInput
  >;
  passwordPolicies?: Maybe<PasswordPolicyUpdateManyWithoutCompanyInput>;
  users?: Maybe<UserUpdateManyWithoutCompanyInput>;
}

export interface UserRoleWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  users_every?: Maybe<UserWhereInput>;
  users_some?: Maybe<UserWhereInput>;
  users_none?: Maybe<UserWhereInput>;
  AND?: Maybe<UserRoleWhereInput[] | UserRoleWhereInput>;
  OR?: Maybe<UserRoleWhereInput[] | UserRoleWhereInput>;
  NOT?: Maybe<UserRoleWhereInput[] | UserRoleWhereInput>;
}

export interface PasswordPolicyUpdateManyWithoutCompanyInput {
  create?: Maybe<
    | PasswordPolicyCreateWithoutCompanyInput[]
    | PasswordPolicyCreateWithoutCompanyInput
  >;
  delete?: Maybe<
    PasswordPolicyWhereUniqueInput[] | PasswordPolicyWhereUniqueInput
  >;
  connect?: Maybe<
    PasswordPolicyWhereUniqueInput[] | PasswordPolicyWhereUniqueInput
  >;
  set?: Maybe<
    PasswordPolicyWhereUniqueInput[] | PasswordPolicyWhereUniqueInput
  >;
  disconnect?: Maybe<
    PasswordPolicyWhereUniqueInput[] | PasswordPolicyWhereUniqueInput
  >;
  update?: Maybe<
    | PasswordPolicyUpdateWithWhereUniqueWithoutCompanyInput[]
    | PasswordPolicyUpdateWithWhereUniqueWithoutCompanyInput
  >;
  upsert?: Maybe<
    | PasswordPolicyUpsertWithWhereUniqueWithoutCompanyInput[]
    | PasswordPolicyUpsertWithWhereUniqueWithoutCompanyInput
  >;
  deleteMany?: Maybe<
    PasswordPolicyScalarWhereInput[] | PasswordPolicyScalarWhereInput
  >;
  updateMany?: Maybe<
    | PasswordPolicyUpdateManyWithWhereNestedInput[]
    | PasswordPolicyUpdateManyWithWhereNestedInput
  >;
}

export interface ProtocolDataWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  network?: Maybe<NetworkWhereInput>;
  networkProtocol?: Maybe<NetworkProtocolWhereInput>;
  dataIdentifier?: Maybe<String>;
  dataIdentifier_not?: Maybe<String>;
  dataIdentifier_in?: Maybe<String[] | String>;
  dataIdentifier_not_in?: Maybe<String[] | String>;
  dataIdentifier_lt?: Maybe<String>;
  dataIdentifier_lte?: Maybe<String>;
  dataIdentifier_gt?: Maybe<String>;
  dataIdentifier_gte?: Maybe<String>;
  dataIdentifier_contains?: Maybe<String>;
  dataIdentifier_not_contains?: Maybe<String>;
  dataIdentifier_starts_with?: Maybe<String>;
  dataIdentifier_not_starts_with?: Maybe<String>;
  dataIdentifier_ends_with?: Maybe<String>;
  dataIdentifier_not_ends_with?: Maybe<String>;
  dataValue?: Maybe<String>;
  dataValue_not?: Maybe<String>;
  dataValue_in?: Maybe<String[] | String>;
  dataValue_not_in?: Maybe<String[] | String>;
  dataValue_lt?: Maybe<String>;
  dataValue_lte?: Maybe<String>;
  dataValue_gt?: Maybe<String>;
  dataValue_gte?: Maybe<String>;
  dataValue_contains?: Maybe<String>;
  dataValue_not_contains?: Maybe<String>;
  dataValue_starts_with?: Maybe<String>;
  dataValue_not_starts_with?: Maybe<String>;
  dataValue_ends_with?: Maybe<String>;
  dataValue_not_ends_with?: Maybe<String>;
  AND?: Maybe<ProtocolDataWhereInput[] | ProtocolDataWhereInput>;
  OR?: Maybe<ProtocolDataWhereInput[] | ProtocolDataWhereInput>;
  NOT?: Maybe<ProtocolDataWhereInput[] | ProtocolDataWhereInput>;
}

export interface PasswordPolicyUpdateWithWhereUniqueWithoutCompanyInput {
  where: PasswordPolicyWhereUniqueInput;
  data: PasswordPolicyUpdateWithoutCompanyDataInput;
}

export interface NetworkWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  networkProvider?: Maybe<NetworkProviderWhereInput>;
  networkType?: Maybe<NetworkTypeWhereInput>;
  networkProtocol?: Maybe<NetworkProtocolWhereInput>;
  baseUrl?: Maybe<String>;
  baseUrl_not?: Maybe<String>;
  baseUrl_in?: Maybe<String[] | String>;
  baseUrl_not_in?: Maybe<String[] | String>;
  baseUrl_lt?: Maybe<String>;
  baseUrl_lte?: Maybe<String>;
  baseUrl_gt?: Maybe<String>;
  baseUrl_gte?: Maybe<String>;
  baseUrl_contains?: Maybe<String>;
  baseUrl_not_contains?: Maybe<String>;
  baseUrl_starts_with?: Maybe<String>;
  baseUrl_not_starts_with?: Maybe<String>;
  baseUrl_ends_with?: Maybe<String>;
  baseUrl_not_ends_with?: Maybe<String>;
  securityData?: Maybe<String>;
  securityData_not?: Maybe<String>;
  securityData_in?: Maybe<String[] | String>;
  securityData_not_in?: Maybe<String[] | String>;
  securityData_lt?: Maybe<String>;
  securityData_lte?: Maybe<String>;
  securityData_gt?: Maybe<String>;
  securityData_gte?: Maybe<String>;
  securityData_contains?: Maybe<String>;
  securityData_not_contains?: Maybe<String>;
  securityData_starts_with?: Maybe<String>;
  securityData_not_starts_with?: Maybe<String>;
  securityData_ends_with?: Maybe<String>;
  securityData_not_ends_with?: Maybe<String>;
  protocolData_every?: Maybe<ProtocolDataWhereInput>;
  protocolData_some?: Maybe<ProtocolDataWhereInput>;
  protocolData_none?: Maybe<ProtocolDataWhereInput>;
  AND?: Maybe<NetworkWhereInput[] | NetworkWhereInput>;
  OR?: Maybe<NetworkWhereInput[] | NetworkWhereInput>;
  NOT?: Maybe<NetworkWhereInput[] | NetworkWhereInput>;
}

export interface ApplicationUpdateOneRequiredWithoutApplicationNetworkTypeLinksInput {
  create?: Maybe<ApplicationCreateWithoutApplicationNetworkTypeLinksInput>;
  update?: Maybe<ApplicationUpdateWithoutApplicationNetworkTypeLinksDataInput>;
  upsert?: Maybe<ApplicationUpsertWithoutApplicationNetworkTypeLinksInput>;
  connect?: Maybe<ApplicationWhereUniqueInput>;
}

export interface CompanyCreateOneWithoutUsersInput {
  create?: Maybe<CompanyCreateWithoutUsersInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface ApplicationUpdateWithoutApplicationNetworkTypeLinksDataInput {
  company?: Maybe<CompanyUpdateOneWithoutApplicationsInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  baseUrl?: Maybe<String>;
  enabled?: Maybe<Boolean>;
  reportingProtocol?: Maybe<ReportingProtocolUpdateOneWithoutApplicationsInput>;
  devices?: Maybe<DeviceUpdateManyWithoutApplicationInput>;
}

export interface PasswordPolicyUpdateWithoutCompanyDataInput {
  ruleText?: Maybe<String>;
  ruleRegExp?: Maybe<String>;
}

export interface ReportingProtocolUpdateOneWithoutApplicationsInput {
  create?: Maybe<ReportingProtocolCreateWithoutApplicationsInput>;
  update?: Maybe<ReportingProtocolUpdateWithoutApplicationsDataInput>;
  upsert?: Maybe<ReportingProtocolUpsertWithoutApplicationsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ReportingProtocolWhereUniqueInput>;
}

export interface DeviceProfileWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  networkType?: Maybe<NetworkTypeWhereInput>;
  company?: Maybe<CompanyWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  networkSettings?: Maybe<String>;
  networkSettings_not?: Maybe<String>;
  networkSettings_in?: Maybe<String[] | String>;
  networkSettings_not_in?: Maybe<String[] | String>;
  networkSettings_lt?: Maybe<String>;
  networkSettings_lte?: Maybe<String>;
  networkSettings_gt?: Maybe<String>;
  networkSettings_gte?: Maybe<String>;
  networkSettings_contains?: Maybe<String>;
  networkSettings_not_contains?: Maybe<String>;
  networkSettings_starts_with?: Maybe<String>;
  networkSettings_not_starts_with?: Maybe<String>;
  networkSettings_ends_with?: Maybe<String>;
  networkSettings_not_ends_with?: Maybe<String>;
  deviceNetworkTypeLinks_every?: Maybe<DeviceNetworkTypeLinkWhereInput>;
  deviceNetworkTypeLinks_some?: Maybe<DeviceNetworkTypeLinkWhereInput>;
  deviceNetworkTypeLinks_none?: Maybe<DeviceNetworkTypeLinkWhereInput>;
  AND?: Maybe<DeviceProfileWhereInput[] | DeviceProfileWhereInput>;
  OR?: Maybe<DeviceProfileWhereInput[] | DeviceProfileWhereInput>;
  NOT?: Maybe<DeviceProfileWhereInput[] | DeviceProfileWhereInput>;
}

export interface ReportingProtocolUpdateWithoutApplicationsDataInput {
  name?: Maybe<String>;
  protocolHandler?: Maybe<String>;
}

export interface ReportingProtocolSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ReportingProtocolWhereInput>;
  AND?: Maybe<
    | ReportingProtocolSubscriptionWhereInput[]
    | ReportingProtocolSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ReportingProtocolSubscriptionWhereInput[]
    | ReportingProtocolSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ReportingProtocolSubscriptionWhereInput[]
    | ReportingProtocolSubscriptionWhereInput
  >;
}

export interface ReportingProtocolUpsertWithoutApplicationsInput {
  update: ReportingProtocolUpdateWithoutApplicationsDataInput;
  create: ReportingProtocolCreateWithoutApplicationsInput;
}

export interface DeviceWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  application?: Maybe<ApplicationWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  deviceModel?: Maybe<String>;
  deviceModel_not?: Maybe<String>;
  deviceModel_in?: Maybe<String[] | String>;
  deviceModel_not_in?: Maybe<String[] | String>;
  deviceModel_lt?: Maybe<String>;
  deviceModel_lte?: Maybe<String>;
  deviceModel_gt?: Maybe<String>;
  deviceModel_gte?: Maybe<String>;
  deviceModel_contains?: Maybe<String>;
  deviceModel_not_contains?: Maybe<String>;
  deviceModel_starts_with?: Maybe<String>;
  deviceModel_not_starts_with?: Maybe<String>;
  deviceModel_ends_with?: Maybe<String>;
  deviceModel_not_ends_with?: Maybe<String>;
  deviceNetworkTypeLinks_every?: Maybe<DeviceNetworkTypeLinkWhereInput>;
  deviceNetworkTypeLinks_some?: Maybe<DeviceNetworkTypeLinkWhereInput>;
  deviceNetworkTypeLinks_none?: Maybe<DeviceNetworkTypeLinkWhereInput>;
  AND?: Maybe<DeviceWhereInput[] | DeviceWhereInput>;
  OR?: Maybe<DeviceWhereInput[] | DeviceWhereInput>;
  NOT?: Maybe<DeviceWhereInput[] | DeviceWhereInput>;
}

export interface DeviceUpdateManyWithoutApplicationInput {
  create?: Maybe<
    DeviceCreateWithoutApplicationInput[] | DeviceCreateWithoutApplicationInput
  >;
  delete?: Maybe<DeviceWhereUniqueInput[] | DeviceWhereUniqueInput>;
  connect?: Maybe<DeviceWhereUniqueInput[] | DeviceWhereUniqueInput>;
  set?: Maybe<DeviceWhereUniqueInput[] | DeviceWhereUniqueInput>;
  disconnect?: Maybe<DeviceWhereUniqueInput[] | DeviceWhereUniqueInput>;
  update?: Maybe<
    | DeviceUpdateWithWhereUniqueWithoutApplicationInput[]
    | DeviceUpdateWithWhereUniqueWithoutApplicationInput
  >;
  upsert?: Maybe<
    | DeviceUpsertWithWhereUniqueWithoutApplicationInput[]
    | DeviceUpsertWithWhereUniqueWithoutApplicationInput
  >;
  deleteMany?: Maybe<DeviceScalarWhereInput[] | DeviceScalarWhereInput>;
  updateMany?: Maybe<
    | DeviceUpdateManyWithWhereNestedInput[]
    | DeviceUpdateManyWithWhereNestedInput
  >;
}

export interface PasswordPolicySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PasswordPolicyWhereInput>;
  AND?: Maybe<
    | PasswordPolicySubscriptionWhereInput[]
    | PasswordPolicySubscriptionWhereInput
  >;
  OR?: Maybe<
    | PasswordPolicySubscriptionWhereInput[]
    | PasswordPolicySubscriptionWhereInput
  >;
  NOT?: Maybe<
    | PasswordPolicySubscriptionWhereInput[]
    | PasswordPolicySubscriptionWhereInput
  >;
}

export interface DeviceUpdateWithWhereUniqueWithoutApplicationInput {
  where: DeviceWhereUniqueInput;
  data: DeviceUpdateWithoutApplicationDataInput;
}

export interface NetworkTypeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<NetworkTypeWhereInput>;
  AND?: Maybe<
    NetworkTypeSubscriptionWhereInput[] | NetworkTypeSubscriptionWhereInput
  >;
  OR?: Maybe<
    NetworkTypeSubscriptionWhereInput[] | NetworkTypeSubscriptionWhereInput
  >;
  NOT?: Maybe<
    NetworkTypeSubscriptionWhereInput[] | NetworkTypeSubscriptionWhereInput
  >;
}

export interface DeviceUpdateWithoutApplicationDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  deviceModel?: Maybe<String>;
  deviceNetworkTypeLinks?: Maybe<
    DeviceNetworkTypeLinkUpdateManyWithoutDeviceInput
  >;
}

export interface NetworkTypeWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  applicationNetworkTypeLinks_every?: Maybe<
    ApplicationNetworkTypeLinkWhereInput
  >;
  applicationNetworkTypeLinks_some?: Maybe<
    ApplicationNetworkTypeLinkWhereInput
  >;
  applicationNetworkTypeLinks_none?: Maybe<
    ApplicationNetworkTypeLinkWhereInput
  >;
  companyNetworkTypeLinks_every?: Maybe<CompanyNetworkTypeLinkWhereInput>;
  companyNetworkTypeLinks_some?: Maybe<CompanyNetworkTypeLinkWhereInput>;
  companyNetworkTypeLinks_none?: Maybe<CompanyNetworkTypeLinkWhereInput>;
  deviceNetworkTypeLinks_every?: Maybe<DeviceNetworkTypeLinkWhereInput>;
  deviceNetworkTypeLinks_some?: Maybe<DeviceNetworkTypeLinkWhereInput>;
  deviceNetworkTypeLinks_none?: Maybe<DeviceNetworkTypeLinkWhereInput>;
  deviceProfiles_every?: Maybe<DeviceProfileWhereInput>;
  deviceProfiles_some?: Maybe<DeviceProfileWhereInput>;
  deviceProfiles_none?: Maybe<DeviceProfileWhereInput>;
  networkProtocols_every?: Maybe<NetworkProtocolWhereInput>;
  networkProtocols_some?: Maybe<NetworkProtocolWhereInput>;
  networkProtocols_none?: Maybe<NetworkProtocolWhereInput>;
  networks_every?: Maybe<NetworkWhereInput>;
  networks_some?: Maybe<NetworkWhereInput>;
  networks_none?: Maybe<NetworkWhereInput>;
  AND?: Maybe<NetworkTypeWhereInput[] | NetworkTypeWhereInput>;
  OR?: Maybe<NetworkTypeWhereInput[] | NetworkTypeWhereInput>;
  NOT?: Maybe<NetworkTypeWhereInput[] | NetworkTypeWhereInput>;
}

export interface DeviceNetworkTypeLinkUpdateManyWithoutDeviceInput {
  create?: Maybe<
    | DeviceNetworkTypeLinkCreateWithoutDeviceInput[]
    | DeviceNetworkTypeLinkCreateWithoutDeviceInput
  >;
  delete?: Maybe<
    | DeviceNetworkTypeLinkWhereUniqueInput[]
    | DeviceNetworkTypeLinkWhereUniqueInput
  >;
  connect?: Maybe<
    | DeviceNetworkTypeLinkWhereUniqueInput[]
    | DeviceNetworkTypeLinkWhereUniqueInput
  >;
  set?: Maybe<
    | DeviceNetworkTypeLinkWhereUniqueInput[]
    | DeviceNetworkTypeLinkWhereUniqueInput
  >;
  disconnect?: Maybe<
    | DeviceNetworkTypeLinkWhereUniqueInput[]
    | DeviceNetworkTypeLinkWhereUniqueInput
  >;
  update?: Maybe<
    | DeviceNetworkTypeLinkUpdateWithWhereUniqueWithoutDeviceInput[]
    | DeviceNetworkTypeLinkUpdateWithWhereUniqueWithoutDeviceInput
  >;
  upsert?: Maybe<
    | DeviceNetworkTypeLinkUpsertWithWhereUniqueWithoutDeviceInput[]
    | DeviceNetworkTypeLinkUpsertWithWhereUniqueWithoutDeviceInput
  >;
  deleteMany?: Maybe<
    | DeviceNetworkTypeLinkScalarWhereInput[]
    | DeviceNetworkTypeLinkScalarWhereInput
  >;
  updateMany?: Maybe<
    | DeviceNetworkTypeLinkUpdateManyWithWhereNestedInput[]
    | DeviceNetworkTypeLinkUpdateManyWithWhereNestedInput
  >;
}

export interface ApplicationNetworkTypeLinkWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  application?: Maybe<ApplicationWhereInput>;
  networkType?: Maybe<NetworkTypeWhereInput>;
  networkSettings?: Maybe<String>;
  networkSettings_not?: Maybe<String>;
  networkSettings_in?: Maybe<String[] | String>;
  networkSettings_not_in?: Maybe<String[] | String>;
  networkSettings_lt?: Maybe<String>;
  networkSettings_lte?: Maybe<String>;
  networkSettings_gt?: Maybe<String>;
  networkSettings_gte?: Maybe<String>;
  networkSettings_contains?: Maybe<String>;
  networkSettings_not_contains?: Maybe<String>;
  networkSettings_starts_with?: Maybe<String>;
  networkSettings_not_starts_with?: Maybe<String>;
  networkSettings_ends_with?: Maybe<String>;
  networkSettings_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    | ApplicationNetworkTypeLinkWhereInput[]
    | ApplicationNetworkTypeLinkWhereInput
  >;
  OR?: Maybe<
    | ApplicationNetworkTypeLinkWhereInput[]
    | ApplicationNetworkTypeLinkWhereInput
  >;
  NOT?: Maybe<
    | ApplicationNetworkTypeLinkWhereInput[]
    | ApplicationNetworkTypeLinkWhereInput
  >;
}

export interface DeviceNetworkTypeLinkUpdateWithWhereUniqueWithoutDeviceInput {
  where: DeviceNetworkTypeLinkWhereUniqueInput;
  data: DeviceNetworkTypeLinkUpdateWithoutDeviceDataInput;
}

export interface ReportingProtocolWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  protocolHandler?: Maybe<String>;
  protocolHandler_not?: Maybe<String>;
  protocolHandler_in?: Maybe<String[] | String>;
  protocolHandler_not_in?: Maybe<String[] | String>;
  protocolHandler_lt?: Maybe<String>;
  protocolHandler_lte?: Maybe<String>;
  protocolHandler_gt?: Maybe<String>;
  protocolHandler_gte?: Maybe<String>;
  protocolHandler_contains?: Maybe<String>;
  protocolHandler_not_contains?: Maybe<String>;
  protocolHandler_starts_with?: Maybe<String>;
  protocolHandler_not_starts_with?: Maybe<String>;
  protocolHandler_ends_with?: Maybe<String>;
  protocolHandler_not_ends_with?: Maybe<String>;
  applications_every?: Maybe<ApplicationWhereInput>;
  applications_some?: Maybe<ApplicationWhereInput>;
  applications_none?: Maybe<ApplicationWhereInput>;
  AND?: Maybe<ReportingProtocolWhereInput[] | ReportingProtocolWhereInput>;
  OR?: Maybe<ReportingProtocolWhereInput[] | ReportingProtocolWhereInput>;
  NOT?: Maybe<ReportingProtocolWhereInput[] | ReportingProtocolWhereInput>;
}

export interface DeviceNetworkTypeLinkUpdateWithoutDeviceDataInput {
  networkType?: Maybe<
    NetworkTypeUpdateOneRequiredWithoutDeviceNetworkTypeLinksInput
  >;
  deviceProfile?: Maybe<
    DeviceProfileUpdateOneRequiredWithoutDeviceNetworkTypeLinksInput
  >;
  networkSettings?: Maybe<String>;
}

export interface DeviceProfileSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DeviceProfileWhereInput>;
  AND?: Maybe<
    DeviceProfileSubscriptionWhereInput[] | DeviceProfileSubscriptionWhereInput
  >;
  OR?: Maybe<
    DeviceProfileSubscriptionWhereInput[] | DeviceProfileSubscriptionWhereInput
  >;
  NOT?: Maybe<
    DeviceProfileSubscriptionWhereInput[] | DeviceProfileSubscriptionWhereInput
  >;
}

export interface NetworkTypeUpdateOneRequiredWithoutDeviceNetworkTypeLinksInput {
  create?: Maybe<NetworkTypeCreateWithoutDeviceNetworkTypeLinksInput>;
  update?: Maybe<NetworkTypeUpdateWithoutDeviceNetworkTypeLinksDataInput>;
  upsert?: Maybe<NetworkTypeUpsertWithoutDeviceNetworkTypeLinksInput>;
  connect?: Maybe<NetworkTypeWhereUniqueInput>;
}

export interface DeviceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DeviceWhereInput>;
  AND?: Maybe<DeviceSubscriptionWhereInput[] | DeviceSubscriptionWhereInput>;
  OR?: Maybe<DeviceSubscriptionWhereInput[] | DeviceSubscriptionWhereInput>;
  NOT?: Maybe<DeviceSubscriptionWhereInput[] | DeviceSubscriptionWhereInput>;
}

export interface NetworkTypeUpdateWithoutDeviceNetworkTypeLinksDataInput {
  name?: Maybe<String>;
  applicationNetworkTypeLinks?: Maybe<
    ApplicationNetworkTypeLinkUpdateManyWithoutNetworkTypeInput
  >;
  companyNetworkTypeLinks?: Maybe<
    CompanyNetworkTypeLinkUpdateManyWithoutNetworkTypeInput
  >;
  deviceProfiles?: Maybe<DeviceProfileUpdateManyWithoutNetworkTypeInput>;
  networkProtocols?: Maybe<NetworkProtocolUpdateManyWithoutNetworkTypeInput>;
  networks?: Maybe<NetworkUpdateManyWithoutNetworkTypeInput>;
}

export interface ApplicationWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  company?: Maybe<CompanyWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  baseUrl?: Maybe<String>;
  baseUrl_not?: Maybe<String>;
  baseUrl_in?: Maybe<String[] | String>;
  baseUrl_not_in?: Maybe<String[] | String>;
  baseUrl_lt?: Maybe<String>;
  baseUrl_lte?: Maybe<String>;
  baseUrl_gt?: Maybe<String>;
  baseUrl_gte?: Maybe<String>;
  baseUrl_contains?: Maybe<String>;
  baseUrl_not_contains?: Maybe<String>;
  baseUrl_starts_with?: Maybe<String>;
  baseUrl_not_starts_with?: Maybe<String>;
  baseUrl_ends_with?: Maybe<String>;
  baseUrl_not_ends_with?: Maybe<String>;
  enabled?: Maybe<Boolean>;
  enabled_not?: Maybe<Boolean>;
  reportingProtocol?: Maybe<ReportingProtocolWhereInput>;
  applicationNetworkTypeLinks_every?: Maybe<
    ApplicationNetworkTypeLinkWhereInput
  >;
  applicationNetworkTypeLinks_some?: Maybe<
    ApplicationNetworkTypeLinkWhereInput
  >;
  applicationNetworkTypeLinks_none?: Maybe<
    ApplicationNetworkTypeLinkWhereInput
  >;
  devices_every?: Maybe<DeviceWhereInput>;
  devices_some?: Maybe<DeviceWhereInput>;
  devices_none?: Maybe<DeviceWhereInput>;
  AND?: Maybe<ApplicationWhereInput[] | ApplicationWhereInput>;
  OR?: Maybe<ApplicationWhereInput[] | ApplicationWhereInput>;
  NOT?: Maybe<ApplicationWhereInput[] | ApplicationWhereInput>;
}

export interface CompanyNetworkTypeLinkUpdateManyWithoutNetworkTypeInput {
  create?: Maybe<
    | CompanyNetworkTypeLinkCreateWithoutNetworkTypeInput[]
    | CompanyNetworkTypeLinkCreateWithoutNetworkTypeInput
  >;
  delete?: Maybe<
    | CompanyNetworkTypeLinkWhereUniqueInput[]
    | CompanyNetworkTypeLinkWhereUniqueInput
  >;
  connect?: Maybe<
    | CompanyNetworkTypeLinkWhereUniqueInput[]
    | CompanyNetworkTypeLinkWhereUniqueInput
  >;
  set?: Maybe<
    | CompanyNetworkTypeLinkWhereUniqueInput[]
    | CompanyNetworkTypeLinkWhereUniqueInput
  >;
  disconnect?: Maybe<
    | CompanyNetworkTypeLinkWhereUniqueInput[]
    | CompanyNetworkTypeLinkWhereUniqueInput
  >;
  update?: Maybe<
    | CompanyNetworkTypeLinkUpdateWithWhereUniqueWithoutNetworkTypeInput[]
    | CompanyNetworkTypeLinkUpdateWithWhereUniqueWithoutNetworkTypeInput
  >;
  upsert?: Maybe<
    | CompanyNetworkTypeLinkUpsertWithWhereUniqueWithoutNetworkTypeInput[]
    | CompanyNetworkTypeLinkUpsertWithWhereUniqueWithoutNetworkTypeInput
  >;
  deleteMany?: Maybe<
    | CompanyNetworkTypeLinkScalarWhereInput[]
    | CompanyNetworkTypeLinkScalarWhereInput
  >;
  updateMany?: Maybe<
    | CompanyNetworkTypeLinkUpdateManyWithWhereNestedInput[]
    | CompanyNetworkTypeLinkUpdateManyWithWhereNestedInput
  >;
}

export interface CompanySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CompanyWhereInput>;
  AND?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>;
  OR?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>;
  NOT?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>;
}

export interface CompanyNetworkTypeLinkUpdateWithWhereUniqueWithoutNetworkTypeInput {
  where: CompanyNetworkTypeLinkWhereUniqueInput;
  data: CompanyNetworkTypeLinkUpdateWithoutNetworkTypeDataInput;
}

export interface ApplicationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ApplicationWhereInput>;
  AND?: Maybe<
    ApplicationSubscriptionWhereInput[] | ApplicationSubscriptionWhereInput
  >;
  OR?: Maybe<
    ApplicationSubscriptionWhereInput[] | ApplicationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ApplicationSubscriptionWhereInput[] | ApplicationSubscriptionWhereInput
  >;
}

export interface CompanyNetworkTypeLinkUpdateWithoutNetworkTypeDataInput {
  company?: Maybe<CompanyUpdateOneRequiredWithoutCompanyNetworkTypeLinksInput>;
  networkSettings?: Maybe<String>;
}

export interface UserRoleUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface CompanyUpdateOneRequiredWithoutCompanyNetworkTypeLinksInput {
  create?: Maybe<CompanyCreateWithoutCompanyNetworkTypeLinksInput>;
  update?: Maybe<CompanyUpdateWithoutCompanyNetworkTypeLinksDataInput>;
  upsert?: Maybe<CompanyUpsertWithoutCompanyNetworkTypeLinksInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface UserUpdateWithoutRoleDataInput {
  username?: Maybe<String>;
  email?: Maybe<String>;
  lastVerifiedEmail?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  company?: Maybe<CompanyUpdateOneRequiredWithoutUsersInput>;
  passwordHash?: Maybe<String>;
  emailVerifications?: Maybe<EmailVerificationUpdateManyWithoutUserInput>;
}

export interface CompanyUpdateWithoutCompanyNetworkTypeLinksDataInput {
  name?: Maybe<String>;
  type?: Maybe<CompanyTypeUpdateOneWithoutCompaniesInput>;
  applications?: Maybe<ApplicationUpdateManyWithoutCompanyInput>;
  deviceProfiles?: Maybe<DeviceProfileUpdateManyWithoutCompanyInput>;
  passwordPolicies?: Maybe<PasswordPolicyUpdateManyWithoutCompanyInput>;
  users?: Maybe<UserUpdateManyWithoutCompanyInput>;
}

export interface UserUpdateWithWhereUniqueWithoutRoleInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutRoleDataInput;
}

export interface ApplicationUpdateManyWithoutCompanyInput {
  create?: Maybe<
    | ApplicationCreateWithoutCompanyInput[]
    | ApplicationCreateWithoutCompanyInput
  >;
  delete?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
  connect?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
  set?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
  disconnect?: Maybe<
    ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput
  >;
  update?: Maybe<
    | ApplicationUpdateWithWhereUniqueWithoutCompanyInput[]
    | ApplicationUpdateWithWhereUniqueWithoutCompanyInput
  >;
  upsert?: Maybe<
    | ApplicationUpsertWithWhereUniqueWithoutCompanyInput[]
    | ApplicationUpsertWithWhereUniqueWithoutCompanyInput
  >;
  deleteMany?: Maybe<
    ApplicationScalarWhereInput[] | ApplicationScalarWhereInput
  >;
  updateMany?: Maybe<
    | ApplicationUpdateManyWithWhereNestedInput[]
    | ApplicationUpdateManyWithWhereNestedInput
  >;
}

export interface UserRoleUpdateInput {
  name?: Maybe<String>;
  users?: Maybe<UserUpdateManyWithoutRoleInput>;
}

export interface ApplicationUpdateWithWhereUniqueWithoutCompanyInput {
  where: ApplicationWhereUniqueInput;
  data: ApplicationUpdateWithoutCompanyDataInput;
}

export interface UserCreateWithoutRoleInput {
  username?: Maybe<String>;
  email?: Maybe<String>;
  lastVerifiedEmail?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  company: CompanyCreateOneWithoutUsersInput;
  passwordHash: String;
  emailVerifications?: Maybe<EmailVerificationCreateManyWithoutUserInput>;
}

export interface ApplicationUpdateWithoutCompanyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  baseUrl?: Maybe<String>;
  enabled?: Maybe<Boolean>;
  reportingProtocol?: Maybe<ReportingProtocolUpdateOneWithoutApplicationsInput>;
  applicationNetworkTypeLinks?: Maybe<
    ApplicationNetworkTypeLinkUpdateManyWithoutApplicationInput
  >;
  devices?: Maybe<DeviceUpdateManyWithoutApplicationInput>;
}

export interface UserRoleCreateInput {
  name?: Maybe<String>;
  users?: Maybe<UserCreateManyWithoutRoleInput>;
}

export interface ApplicationNetworkTypeLinkUpdateManyWithoutApplicationInput {
  create?: Maybe<
    | ApplicationNetworkTypeLinkCreateWithoutApplicationInput[]
    | ApplicationNetworkTypeLinkCreateWithoutApplicationInput
  >;
  delete?: Maybe<
    | ApplicationNetworkTypeLinkWhereUniqueInput[]
    | ApplicationNetworkTypeLinkWhereUniqueInput
  >;
  connect?: Maybe<
    | ApplicationNetworkTypeLinkWhereUniqueInput[]
    | ApplicationNetworkTypeLinkWhereUniqueInput
  >;
  set?: Maybe<
    | ApplicationNetworkTypeLinkWhereUniqueInput[]
    | ApplicationNetworkTypeLinkWhereUniqueInput
  >;
  disconnect?: Maybe<
    | ApplicationNetworkTypeLinkWhereUniqueInput[]
    | ApplicationNetworkTypeLinkWhereUniqueInput
  >;
  update?: Maybe<
    | ApplicationNetworkTypeLinkUpdateWithWhereUniqueWithoutApplicationInput[]
    | ApplicationNetworkTypeLinkUpdateWithWhereUniqueWithoutApplicationInput
  >;
  upsert?: Maybe<
    | ApplicationNetworkTypeLinkUpsertWithWhereUniqueWithoutApplicationInput[]
    | ApplicationNetworkTypeLinkUpsertWithWhereUniqueWithoutApplicationInput
  >;
  deleteMany?: Maybe<
    | ApplicationNetworkTypeLinkScalarWhereInput[]
    | ApplicationNetworkTypeLinkScalarWhereInput
  >;
  updateMany?: Maybe<
    | ApplicationNetworkTypeLinkUpdateManyWithWhereNestedInput[]
    | ApplicationNetworkTypeLinkUpdateManyWithWhereNestedInput
  >;
}

export interface CompanyTypeWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  companies_every?: Maybe<CompanyWhereInput>;
  companies_some?: Maybe<CompanyWhereInput>;
  companies_none?: Maybe<CompanyWhereInput>;
  AND?: Maybe<CompanyTypeWhereInput[] | CompanyTypeWhereInput>;
  OR?: Maybe<CompanyTypeWhereInput[] | CompanyTypeWhereInput>;
  NOT?: Maybe<CompanyTypeWhereInput[] | CompanyTypeWhereInput>;
}

export interface ApplicationNetworkTypeLinkUpdateWithWhereUniqueWithoutApplicationInput {
  where: ApplicationNetworkTypeLinkWhereUniqueInput;
  data: ApplicationNetworkTypeLinkUpdateWithoutApplicationDataInput;
}

export interface UserUpdateInput {
  username?: Maybe<String>;
  email?: Maybe<String>;
  lastVerifiedEmail?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  company?: Maybe<CompanyUpdateOneRequiredWithoutUsersInput>;
  passwordHash?: Maybe<String>;
  role?: Maybe<UserRoleUpdateOneRequiredWithoutUsersInput>;
  emailVerifications?: Maybe<EmailVerificationUpdateManyWithoutUserInput>;
}

export interface ApplicationNetworkTypeLinkUpdateWithoutApplicationDataInput {
  networkType?: Maybe<
    NetworkTypeUpdateOneRequiredWithoutApplicationNetworkTypeLinksInput
  >;
  networkSettings?: Maybe<String>;
}

export type DeviceWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface NetworkTypeUpdateOneRequiredWithoutApplicationNetworkTypeLinksInput {
  create?: Maybe<NetworkTypeCreateWithoutApplicationNetworkTypeLinksInput>;
  update?: Maybe<NetworkTypeUpdateWithoutApplicationNetworkTypeLinksDataInput>;
  upsert?: Maybe<NetworkTypeUpsertWithoutApplicationNetworkTypeLinksInput>;
  connect?: Maybe<NetworkTypeWhereUniqueInput>;
}

export interface ApplicationUpsertWithWhereUniqueWithoutReportingProtocolInput {
  where: ApplicationWhereUniqueInput;
  update: ApplicationUpdateWithoutReportingProtocolDataInput;
  create: ApplicationCreateWithoutReportingProtocolInput;
}

export interface NetworkTypeUpdateWithoutApplicationNetworkTypeLinksDataInput {
  name?: Maybe<String>;
  companyNetworkTypeLinks?: Maybe<
    CompanyNetworkTypeLinkUpdateManyWithoutNetworkTypeInput
  >;
  deviceNetworkTypeLinks?: Maybe<
    DeviceNetworkTypeLinkUpdateManyWithoutNetworkTypeInput
  >;
  deviceProfiles?: Maybe<DeviceProfileUpdateManyWithoutNetworkTypeInput>;
  networkProtocols?: Maybe<NetworkProtocolUpdateManyWithoutNetworkTypeInput>;
  networks?: Maybe<NetworkUpdateManyWithoutNetworkTypeInput>;
}

export type DeviceNetworkTypeLinkWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface DeviceNetworkTypeLinkUpdateManyWithoutNetworkTypeInput {
  create?: Maybe<
    | DeviceNetworkTypeLinkCreateWithoutNetworkTypeInput[]
    | DeviceNetworkTypeLinkCreateWithoutNetworkTypeInput
  >;
  delete?: Maybe<
    | DeviceNetworkTypeLinkWhereUniqueInput[]
    | DeviceNetworkTypeLinkWhereUniqueInput
  >;
  connect?: Maybe<
    | DeviceNetworkTypeLinkWhereUniqueInput[]
    | DeviceNetworkTypeLinkWhereUniqueInput
  >;
  set?: Maybe<
    | DeviceNetworkTypeLinkWhereUniqueInput[]
    | DeviceNetworkTypeLinkWhereUniqueInput
  >;
  disconnect?: Maybe<
    | DeviceNetworkTypeLinkWhereUniqueInput[]
    | DeviceNetworkTypeLinkWhereUniqueInput
  >;
  update?: Maybe<
    | DeviceNetworkTypeLinkUpdateWithWhereUniqueWithoutNetworkTypeInput[]
    | DeviceNetworkTypeLinkUpdateWithWhereUniqueWithoutNetworkTypeInput
  >;
  upsert?: Maybe<
    | DeviceNetworkTypeLinkUpsertWithWhereUniqueWithoutNetworkTypeInput[]
    | DeviceNetworkTypeLinkUpsertWithWhereUniqueWithoutNetworkTypeInput
  >;
  deleteMany?: Maybe<
    | DeviceNetworkTypeLinkScalarWhereInput[]
    | DeviceNetworkTypeLinkScalarWhereInput
  >;
  updateMany?: Maybe<
    | DeviceNetworkTypeLinkUpdateManyWithWhereNestedInput[]
    | DeviceNetworkTypeLinkUpdateManyWithWhereNestedInput
  >;
}

export interface ApplicationUpdateManyWithoutReportingProtocolInput {
  create?: Maybe<
    | ApplicationCreateWithoutReportingProtocolInput[]
    | ApplicationCreateWithoutReportingProtocolInput
  >;
  delete?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
  connect?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
  set?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
  disconnect?: Maybe<
    ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput
  >;
  update?: Maybe<
    | ApplicationUpdateWithWhereUniqueWithoutReportingProtocolInput[]
    | ApplicationUpdateWithWhereUniqueWithoutReportingProtocolInput
  >;
  upsert?: Maybe<
    | ApplicationUpsertWithWhereUniqueWithoutReportingProtocolInput[]
    | ApplicationUpsertWithWhereUniqueWithoutReportingProtocolInput
  >;
  deleteMany?: Maybe<
    ApplicationScalarWhereInput[] | ApplicationScalarWhereInput
  >;
  updateMany?: Maybe<
    | ApplicationUpdateManyWithWhereNestedInput[]
    | ApplicationUpdateManyWithWhereNestedInput
  >;
}

export interface DeviceNetworkTypeLinkUpdateWithWhereUniqueWithoutNetworkTypeInput {
  where: DeviceNetworkTypeLinkWhereUniqueInput;
  data: DeviceNetworkTypeLinkUpdateWithoutNetworkTypeDataInput;
}

export type DeviceProfileWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface DeviceNetworkTypeLinkUpdateWithoutNetworkTypeDataInput {
  device?: Maybe<DeviceUpdateOneRequiredWithoutDeviceNetworkTypeLinksInput>;
  deviceProfile?: Maybe<
    DeviceProfileUpdateOneRequiredWithoutDeviceNetworkTypeLinksInput
  >;
  networkSettings?: Maybe<String>;
}

export interface ApplicationCreateManyWithoutReportingProtocolInput {
  create?: Maybe<
    | ApplicationCreateWithoutReportingProtocolInput[]
    | ApplicationCreateWithoutReportingProtocolInput
  >;
  connect?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
}

export interface DeviceUpdateOneRequiredWithoutDeviceNetworkTypeLinksInput {
  create?: Maybe<DeviceCreateWithoutDeviceNetworkTypeLinksInput>;
  update?: Maybe<DeviceUpdateWithoutDeviceNetworkTypeLinksDataInput>;
  upsert?: Maybe<DeviceUpsertWithoutDeviceNetworkTypeLinksInput>;
  connect?: Maybe<DeviceWhereUniqueInput>;
}

export type EmailVerificationWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
  uuid?: Maybe<String>;
}>;

export interface DeviceUpdateWithoutDeviceNetworkTypeLinksDataInput {
  application?: Maybe<ApplicationUpdateOneRequiredWithoutDevicesInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  deviceModel?: Maybe<String>;
}

export interface ProtocolDataUpdateInput {
  network?: Maybe<NetworkUpdateOneRequiredWithoutProtocolDataInput>;
  networkProtocol?: Maybe<
    NetworkProtocolUpdateOneRequiredWithoutProtocolDataInput
  >;
  dataIdentifier?: Maybe<String>;
  dataValue?: Maybe<String>;
}

export interface ApplicationUpdateOneRequiredWithoutDevicesInput {
  create?: Maybe<ApplicationCreateWithoutDevicesInput>;
  update?: Maybe<ApplicationUpdateWithoutDevicesDataInput>;
  upsert?: Maybe<ApplicationUpsertWithoutDevicesInput>;
  connect?: Maybe<ApplicationWhereUniqueInput>;
}

export type NetworkWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface ApplicationUpdateWithoutDevicesDataInput {
  company?: Maybe<CompanyUpdateOneWithoutApplicationsInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  baseUrl?: Maybe<String>;
  enabled?: Maybe<Boolean>;
  reportingProtocol?: Maybe<ReportingProtocolUpdateOneWithoutApplicationsInput>;
  applicationNetworkTypeLinks?: Maybe<
    ApplicationNetworkTypeLinkUpdateManyWithoutApplicationInput
  >;
}

export interface CompanyUpsertWithoutPasswordPoliciesInput {
  update: CompanyUpdateWithoutPasswordPoliciesDataInput;
  create: CompanyCreateWithoutPasswordPoliciesInput;
}

export interface ApplicationUpsertWithoutDevicesInput {
  update: ApplicationUpdateWithoutDevicesDataInput;
  create: ApplicationCreateWithoutDevicesInput;
}

export type NetworkProtocolWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
  protocolHandler?: Maybe<String>;
}>;

export interface DeviceUpsertWithoutDeviceNetworkTypeLinksInput {
  update: DeviceUpdateWithoutDeviceNetworkTypeLinksDataInput;
  create: DeviceCreateWithoutDeviceNetworkTypeLinksInput;
}

export interface PasswordPolicyUpdateInput {
  ruleText?: Maybe<String>;
  ruleRegExp?: Maybe<String>;
  company?: Maybe<CompanyUpdateOneWithoutPasswordPoliciesInput>;
}

export interface DeviceProfileUpdateOneRequiredWithoutDeviceNetworkTypeLinksInput {
  create?: Maybe<DeviceProfileCreateWithoutDeviceNetworkTypeLinksInput>;
  update?: Maybe<DeviceProfileUpdateWithoutDeviceNetworkTypeLinksDataInput>;
  upsert?: Maybe<DeviceProfileUpsertWithoutDeviceNetworkTypeLinksInput>;
  connect?: Maybe<DeviceProfileWhereUniqueInput>;
}

export type NetworkProviderWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface DeviceProfileUpdateWithoutDeviceNetworkTypeLinksDataInput {
  networkType?: Maybe<NetworkTypeUpdateOneRequiredWithoutDeviceProfilesInput>;
  company?: Maybe<CompanyUpdateOneRequiredWithoutDeviceProfilesInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  networkSettings?: Maybe<String>;
}

export interface CompanyCreateOneWithoutPasswordPoliciesInput {
  create?: Maybe<CompanyCreateWithoutPasswordPoliciesInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface NetworkTypeUpdateOneRequiredWithoutDeviceProfilesInput {
  create?: Maybe<NetworkTypeCreateWithoutDeviceProfilesInput>;
  update?: Maybe<NetworkTypeUpdateWithoutDeviceProfilesDataInput>;
  upsert?: Maybe<NetworkTypeUpsertWithoutDeviceProfilesInput>;
  connect?: Maybe<NetworkTypeWhereUniqueInput>;
}

export interface NetworkTypeUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface NetworkTypeUpdateWithoutDeviceProfilesDataInput {
  name?: Maybe<String>;
  applicationNetworkTypeLinks?: Maybe<
    ApplicationNetworkTypeLinkUpdateManyWithoutNetworkTypeInput
  >;
  companyNetworkTypeLinks?: Maybe<
    CompanyNetworkTypeLinkUpdateManyWithoutNetworkTypeInput
  >;
  deviceNetworkTypeLinks?: Maybe<
    DeviceNetworkTypeLinkUpdateManyWithoutNetworkTypeInput
  >;
  networkProtocols?: Maybe<NetworkProtocolUpdateManyWithoutNetworkTypeInput>;
  networks?: Maybe<NetworkUpdateManyWithoutNetworkTypeInput>;
}

export interface NetworkTypeUpdateInput {
  name?: Maybe<String>;
  applicationNetworkTypeLinks?: Maybe<
    ApplicationNetworkTypeLinkUpdateManyWithoutNetworkTypeInput
  >;
  companyNetworkTypeLinks?: Maybe<
    CompanyNetworkTypeLinkUpdateManyWithoutNetworkTypeInput
  >;
  deviceNetworkTypeLinks?: Maybe<
    DeviceNetworkTypeLinkUpdateManyWithoutNetworkTypeInput
  >;
  deviceProfiles?: Maybe<DeviceProfileUpdateManyWithoutNetworkTypeInput>;
  networkProtocols?: Maybe<NetworkProtocolUpdateManyWithoutNetworkTypeInput>;
  networks?: Maybe<NetworkUpdateManyWithoutNetworkTypeInput>;
}

export interface NetworkProtocolUpdateManyWithoutNetworkTypeInput {
  create?: Maybe<
    | NetworkProtocolCreateWithoutNetworkTypeInput[]
    | NetworkProtocolCreateWithoutNetworkTypeInput
  >;
  delete?: Maybe<
    NetworkProtocolWhereUniqueInput[] | NetworkProtocolWhereUniqueInput
  >;
  connect?: Maybe<
    NetworkProtocolWhereUniqueInput[] | NetworkProtocolWhereUniqueInput
  >;
  set?: Maybe<
    NetworkProtocolWhereUniqueInput[] | NetworkProtocolWhereUniqueInput
  >;
  disconnect?: Maybe<
    NetworkProtocolWhereUniqueInput[] | NetworkProtocolWhereUniqueInput
  >;
  update?: Maybe<
    | NetworkProtocolUpdateWithWhereUniqueWithoutNetworkTypeInput[]
    | NetworkProtocolUpdateWithWhereUniqueWithoutNetworkTypeInput
  >;
  upsert?: Maybe<
    | NetworkProtocolUpsertWithWhereUniqueWithoutNetworkTypeInput[]
    | NetworkProtocolUpsertWithWhereUniqueWithoutNetworkTypeInput
  >;
  deleteMany?: Maybe<
    NetworkProtocolScalarWhereInput[] | NetworkProtocolScalarWhereInput
  >;
  updateMany?: Maybe<
    | NetworkProtocolUpdateManyWithWhereNestedInput[]
    | NetworkProtocolUpdateManyWithWhereNestedInput
  >;
}

export interface NetworkProviderUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface NetworkProtocolUpdateWithWhereUniqueWithoutNetworkTypeInput {
  where: NetworkProtocolWhereUniqueInput;
  data: NetworkProtocolUpdateWithoutNetworkTypeDataInput;
}

export type PasswordPolicyWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface NetworkProtocolUpdateWithoutNetworkTypeDataInput {
  name?: Maybe<String>;
  protocolHandler?: Maybe<String>;
  networkProtocolVersion?: Maybe<String>;
  masterProtocol?: Maybe<Int>;
  networks?: Maybe<NetworkUpdateManyWithoutNetworkProtocolInput>;
  protocolData?: Maybe<ProtocolDataUpdateManyWithoutNetworkProtocolInput>;
}

export interface NetworkUpdateWithWhereUniqueWithoutNetworkProviderInput {
  where: NetworkWhereUniqueInput;
  data: NetworkUpdateWithoutNetworkProviderDataInput;
}

export interface UserUpdateWithoutEmailVerificationsDataInput {
  username?: Maybe<String>;
  email?: Maybe<String>;
  lastVerifiedEmail?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  company?: Maybe<CompanyUpdateOneRequiredWithoutUsersInput>;
  passwordHash?: Maybe<String>;
  role?: Maybe<UserRoleUpdateOneRequiredWithoutUsersInput>;
}

export type ProtocolDataWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface NetworkUpdateWithWhereUniqueWithoutNetworkProtocolInput {
  where: NetworkWhereUniqueInput;
  data: NetworkUpdateWithoutNetworkProtocolDataInput;
}

export interface NetworkCreateWithoutNetworkProviderInput {
  name?: Maybe<String>;
  networkType: NetworkTypeCreateOneWithoutNetworksInput;
  networkProtocol: NetworkProtocolCreateOneWithoutNetworksInput;
  baseUrl?: Maybe<String>;
  securityData?: Maybe<String>;
  protocolData?: Maybe<ProtocolDataCreateManyWithoutNetworkInput>;
}

export interface NetworkUpdateWithoutNetworkProtocolDataInput {
  name?: Maybe<String>;
  networkProvider?: Maybe<NetworkProviderUpdateOneWithoutNetworksInput>;
  networkType?: Maybe<NetworkTypeUpdateOneRequiredWithoutNetworksInput>;
  baseUrl?: Maybe<String>;
  securityData?: Maybe<String>;
  protocolData?: Maybe<ProtocolDataUpdateManyWithoutNetworkInput>;
}

export type ReportingProtocolWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface NetworkProviderUpdateOneWithoutNetworksInput {
  create?: Maybe<NetworkProviderCreateWithoutNetworksInput>;
  update?: Maybe<NetworkProviderUpdateWithoutNetworksDataInput>;
  upsert?: Maybe<NetworkProviderUpsertWithoutNetworksInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<NetworkProviderWhereUniqueInput>;
}

export interface NetworkProtocolUpdateManyMutationInput {
  name?: Maybe<String>;
  protocolHandler?: Maybe<String>;
  networkProtocolVersion?: Maybe<String>;
  masterProtocol?: Maybe<Int>;
}

export interface NetworkProviderUpdateWithoutNetworksDataInput {
  name?: Maybe<String>;
}

export interface NetworkProtocolCreateInput {
  name?: Maybe<String>;
  protocolHandler?: Maybe<String>;
  networkType: NetworkTypeCreateOneWithoutNetworkProtocolsInput;
  networkProtocolVersion?: Maybe<String>;
  masterProtocol?: Maybe<Int>;
  networks?: Maybe<NetworkCreateManyWithoutNetworkProtocolInput>;
  protocolData?: Maybe<ProtocolDataCreateManyWithoutNetworkProtocolInput>;
}

export interface NetworkProviderUpsertWithoutNetworksInput {
  update: NetworkProviderUpdateWithoutNetworksDataInput;
  create: NetworkProviderCreateWithoutNetworksInput;
}

export interface NetworkUpdateManyMutationInput {
  name?: Maybe<String>;
  baseUrl?: Maybe<String>;
  securityData?: Maybe<String>;
}

export interface NetworkTypeUpdateOneRequiredWithoutNetworksInput {
  create?: Maybe<NetworkTypeCreateWithoutNetworksInput>;
  update?: Maybe<NetworkTypeUpdateWithoutNetworksDataInput>;
  upsert?: Maybe<NetworkTypeUpsertWithoutNetworksInput>;
  connect?: Maybe<NetworkTypeWhereUniqueInput>;
}

export interface NetworkCreateInput {
  name?: Maybe<String>;
  networkProvider?: Maybe<NetworkProviderCreateOneWithoutNetworksInput>;
  networkType: NetworkTypeCreateOneWithoutNetworksInput;
  networkProtocol: NetworkProtocolCreateOneWithoutNetworksInput;
  baseUrl?: Maybe<String>;
  securityData?: Maybe<String>;
  protocolData?: Maybe<ProtocolDataCreateManyWithoutNetworkInput>;
}

export interface NetworkTypeUpdateWithoutNetworksDataInput {
  name?: Maybe<String>;
  applicationNetworkTypeLinks?: Maybe<
    ApplicationNetworkTypeLinkUpdateManyWithoutNetworkTypeInput
  >;
  companyNetworkTypeLinks?: Maybe<
    CompanyNetworkTypeLinkUpdateManyWithoutNetworkTypeInput
  >;
  deviceNetworkTypeLinks?: Maybe<
    DeviceNetworkTypeLinkUpdateManyWithoutNetworkTypeInput
  >;
  deviceProfiles?: Maybe<DeviceProfileUpdateManyWithoutNetworkTypeInput>;
  networkProtocols?: Maybe<NetworkProtocolUpdateManyWithoutNetworkTypeInput>;
}

export interface EmailVerificationUpdateManyMutationInput {
  uuid?: Maybe<String>;
  email?: Maybe<String>;
  changeRequested?: Maybe<String>;
}

export interface DeviceProfileUpdateManyWithoutNetworkTypeInput {
  create?: Maybe<
    | DeviceProfileCreateWithoutNetworkTypeInput[]
    | DeviceProfileCreateWithoutNetworkTypeInput
  >;
  delete?: Maybe<
    DeviceProfileWhereUniqueInput[] | DeviceProfileWhereUniqueInput
  >;
  connect?: Maybe<
    DeviceProfileWhereUniqueInput[] | DeviceProfileWhereUniqueInput
  >;
  set?: Maybe<DeviceProfileWhereUniqueInput[] | DeviceProfileWhereUniqueInput>;
  disconnect?: Maybe<
    DeviceProfileWhereUniqueInput[] | DeviceProfileWhereUniqueInput
  >;
  update?: Maybe<
    | DeviceProfileUpdateWithWhereUniqueWithoutNetworkTypeInput[]
    | DeviceProfileUpdateWithWhereUniqueWithoutNetworkTypeInput
  >;
  upsert?: Maybe<
    | DeviceProfileUpsertWithWhereUniqueWithoutNetworkTypeInput[]
    | DeviceProfileUpsertWithWhereUniqueWithoutNetworkTypeInput
  >;
  deleteMany?: Maybe<
    DeviceProfileScalarWhereInput[] | DeviceProfileScalarWhereInput
  >;
  updateMany?: Maybe<
    | DeviceProfileUpdateManyWithWhereNestedInput[]
    | DeviceProfileUpdateManyWithWhereNestedInput
  >;
}

export interface CompanyUpsertWithoutUsersInput {
  update: CompanyUpdateWithoutUsersDataInput;
  create: CompanyCreateWithoutUsersInput;
}

export interface DeviceProfileUpdateWithWhereUniqueWithoutNetworkTypeInput {
  where: DeviceProfileWhereUniqueInput;
  data: DeviceProfileUpdateWithoutNetworkTypeDataInput;
}

export interface CompanyUpdateOneRequiredWithoutUsersInput {
  create?: Maybe<CompanyCreateWithoutUsersInput>;
  update?: Maybe<CompanyUpdateWithoutUsersDataInput>;
  upsert?: Maybe<CompanyUpsertWithoutUsersInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface DeviceProfileUpdateWithoutNetworkTypeDataInput {
  company?: Maybe<CompanyUpdateOneRequiredWithoutDeviceProfilesInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  networkSettings?: Maybe<String>;
  deviceNetworkTypeLinks?: Maybe<
    DeviceNetworkTypeLinkUpdateManyWithoutDeviceProfileInput
  >;
}

export interface ApplicationCreateInput {
  company?: Maybe<CompanyCreateOneWithoutApplicationsInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  baseUrl?: Maybe<String>;
  enabled?: Maybe<Boolean>;
  reportingProtocol?: Maybe<ReportingProtocolCreateOneWithoutApplicationsInput>;
  applicationNetworkTypeLinks?: Maybe<
    ApplicationNetworkTypeLinkCreateManyWithoutApplicationInput
  >;
  devices?: Maybe<DeviceCreateManyWithoutApplicationInput>;
}

export interface UserWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  lastVerifiedEmail?: Maybe<String>;
  lastVerifiedEmail_not?: Maybe<String>;
  lastVerifiedEmail_in?: Maybe<String[] | String>;
  lastVerifiedEmail_not_in?: Maybe<String[] | String>;
  lastVerifiedEmail_lt?: Maybe<String>;
  lastVerifiedEmail_lte?: Maybe<String>;
  lastVerifiedEmail_gt?: Maybe<String>;
  lastVerifiedEmail_gte?: Maybe<String>;
  lastVerifiedEmail_contains?: Maybe<String>;
  lastVerifiedEmail_not_contains?: Maybe<String>;
  lastVerifiedEmail_starts_with?: Maybe<String>;
  lastVerifiedEmail_not_starts_with?: Maybe<String>;
  lastVerifiedEmail_ends_with?: Maybe<String>;
  lastVerifiedEmail_not_ends_with?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  emailVerified_not?: Maybe<Boolean>;
  company?: Maybe<CompanyWhereInput>;
  passwordHash?: Maybe<String>;
  passwordHash_not?: Maybe<String>;
  passwordHash_in?: Maybe<String[] | String>;
  passwordHash_not_in?: Maybe<String[] | String>;
  passwordHash_lt?: Maybe<String>;
  passwordHash_lte?: Maybe<String>;
  passwordHash_gt?: Maybe<String>;
  passwordHash_gte?: Maybe<String>;
  passwordHash_contains?: Maybe<String>;
  passwordHash_not_contains?: Maybe<String>;
  passwordHash_starts_with?: Maybe<String>;
  passwordHash_not_starts_with?: Maybe<String>;
  passwordHash_ends_with?: Maybe<String>;
  passwordHash_not_ends_with?: Maybe<String>;
  role?: Maybe<UserRoleWhereInput>;
  emailVerifications_every?: Maybe<EmailVerificationWhereInput>;
  emailVerifications_some?: Maybe<EmailVerificationWhereInput>;
  emailVerifications_none?: Maybe<EmailVerificationWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface CompanyCreateWithoutApplicationsInput {
  name?: Maybe<String>;
  type?: Maybe<CompanyTypeCreateOneWithoutCompaniesInput>;
  companyNetworkTypeLinks?: Maybe<
    CompanyNetworkTypeLinkCreateManyWithoutCompanyInput
  >;
  deviceProfiles?: Maybe<DeviceProfileCreateManyWithoutCompanyInput>;
  passwordPolicies?: Maybe<PasswordPolicyCreateManyWithoutCompanyInput>;
  users?: Maybe<UserCreateManyWithoutCompanyInput>;
}

export interface EmailVerificationWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  user?: Maybe<UserWhereInput>;
  uuid?: Maybe<String>;
  uuid_not?: Maybe<String>;
  uuid_in?: Maybe<String[] | String>;
  uuid_not_in?: Maybe<String[] | String>;
  uuid_lt?: Maybe<String>;
  uuid_lte?: Maybe<String>;
  uuid_gt?: Maybe<String>;
  uuid_gte?: Maybe<String>;
  uuid_contains?: Maybe<String>;
  uuid_not_contains?: Maybe<String>;
  uuid_starts_with?: Maybe<String>;
  uuid_not_starts_with?: Maybe<String>;
  uuid_ends_with?: Maybe<String>;
  uuid_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  changeRequested?: Maybe<String>;
  changeRequested_not?: Maybe<String>;
  changeRequested_in?: Maybe<String[] | String>;
  changeRequested_not_in?: Maybe<String[] | String>;
  changeRequested_lt?: Maybe<String>;
  changeRequested_lte?: Maybe<String>;
  changeRequested_gt?: Maybe<String>;
  changeRequested_gte?: Maybe<String>;
  changeRequested_contains?: Maybe<String>;
  changeRequested_not_contains?: Maybe<String>;
  changeRequested_starts_with?: Maybe<String>;
  changeRequested_not_starts_with?: Maybe<String>;
  changeRequested_ends_with?: Maybe<String>;
  changeRequested_not_ends_with?: Maybe<String>;
  AND?: Maybe<EmailVerificationWhereInput[] | EmailVerificationWhereInput>;
  OR?: Maybe<EmailVerificationWhereInput[] | EmailVerificationWhereInput>;
  NOT?: Maybe<EmailVerificationWhereInput[] | EmailVerificationWhereInput>;
}

export interface CompanyTypeCreateWithoutCompaniesInput {
  name?: Maybe<String>;
}

export interface NetworkProviderWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  networks_every?: Maybe<NetworkWhereInput>;
  networks_some?: Maybe<NetworkWhereInput>;
  networks_none?: Maybe<NetworkWhereInput>;
  AND?: Maybe<NetworkProviderWhereInput[] | NetworkProviderWhereInput>;
  OR?: Maybe<NetworkProviderWhereInput[] | NetworkProviderWhereInput>;
  NOT?: Maybe<NetworkProviderWhereInput[] | NetworkProviderWhereInput>;
}

export interface CompanyNetworkTypeLinkCreateWithoutCompanyInput {
  networkType: NetworkTypeCreateOneWithoutCompanyNetworkTypeLinksInput;
  networkSettings?: Maybe<String>;
}

export interface UserUpdateOneRequiredWithoutEmailVerificationsInput {
  create?: Maybe<UserCreateWithoutEmailVerificationsInput>;
  update?: Maybe<UserUpdateWithoutEmailVerificationsDataInput>;
  upsert?: Maybe<UserUpsertWithoutEmailVerificationsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface NetworkTypeCreateWithoutCompanyNetworkTypeLinksInput {
  name: String;
  applicationNetworkTypeLinks?: Maybe<
    ApplicationNetworkTypeLinkCreateManyWithoutNetworkTypeInput
  >;
  deviceNetworkTypeLinks?: Maybe<
    DeviceNetworkTypeLinkCreateManyWithoutNetworkTypeInput
  >;
  deviceProfiles?: Maybe<DeviceProfileCreateManyWithoutNetworkTypeInput>;
  networkProtocols?: Maybe<NetworkProtocolCreateManyWithoutNetworkTypeInput>;
  networks?: Maybe<NetworkCreateManyWithoutNetworkTypeInput>;
}

export interface NetworkProtocolWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  protocolHandler?: Maybe<String>;
  protocolHandler_not?: Maybe<String>;
  protocolHandler_in?: Maybe<String[] | String>;
  protocolHandler_not_in?: Maybe<String[] | String>;
  protocolHandler_lt?: Maybe<String>;
  protocolHandler_lte?: Maybe<String>;
  protocolHandler_gt?: Maybe<String>;
  protocolHandler_gte?: Maybe<String>;
  protocolHandler_contains?: Maybe<String>;
  protocolHandler_not_contains?: Maybe<String>;
  protocolHandler_starts_with?: Maybe<String>;
  protocolHandler_not_starts_with?: Maybe<String>;
  protocolHandler_ends_with?: Maybe<String>;
  protocolHandler_not_ends_with?: Maybe<String>;
  networkType?: Maybe<NetworkTypeWhereInput>;
  networkProtocolVersion?: Maybe<String>;
  networkProtocolVersion_not?: Maybe<String>;
  networkProtocolVersion_in?: Maybe<String[] | String>;
  networkProtocolVersion_not_in?: Maybe<String[] | String>;
  networkProtocolVersion_lt?: Maybe<String>;
  networkProtocolVersion_lte?: Maybe<String>;
  networkProtocolVersion_gt?: Maybe<String>;
  networkProtocolVersion_gte?: Maybe<String>;
  networkProtocolVersion_contains?: Maybe<String>;
  networkProtocolVersion_not_contains?: Maybe<String>;
  networkProtocolVersion_starts_with?: Maybe<String>;
  networkProtocolVersion_not_starts_with?: Maybe<String>;
  networkProtocolVersion_ends_with?: Maybe<String>;
  networkProtocolVersion_not_ends_with?: Maybe<String>;
  masterProtocol?: Maybe<Int>;
  masterProtocol_not?: Maybe<Int>;
  masterProtocol_in?: Maybe<Int[] | Int>;
  masterProtocol_not_in?: Maybe<Int[] | Int>;
  masterProtocol_lt?: Maybe<Int>;
  masterProtocol_lte?: Maybe<Int>;
  masterProtocol_gt?: Maybe<Int>;
  masterProtocol_gte?: Maybe<Int>;
  networks_every?: Maybe<NetworkWhereInput>;
  networks_some?: Maybe<NetworkWhereInput>;
  networks_none?: Maybe<NetworkWhereInput>;
  protocolData_every?: Maybe<ProtocolDataWhereInput>;
  protocolData_some?: Maybe<ProtocolDataWhereInput>;
  protocolData_none?: Maybe<ProtocolDataWhereInput>;
  AND?: Maybe<NetworkProtocolWhereInput[] | NetworkProtocolWhereInput>;
  OR?: Maybe<NetworkProtocolWhereInput[] | NetworkProtocolWhereInput>;
  NOT?: Maybe<NetworkProtocolWhereInput[] | NetworkProtocolWhereInput>;
}

export interface ApplicationNetworkTypeLinkCreateWithoutNetworkTypeInput {
  application: ApplicationCreateOneWithoutApplicationNetworkTypeLinksInput;
  networkSettings?: Maybe<String>;
}

export interface PasswordPolicyUpsertWithWhereUniqueWithoutCompanyInput {
  where: PasswordPolicyWhereUniqueInput;
  update: PasswordPolicyUpdateWithoutCompanyDataInput;
  create: PasswordPolicyCreateWithoutCompanyInput;
}

export interface ApplicationCreateWithoutApplicationNetworkTypeLinksInput {
  company?: Maybe<CompanyCreateOneWithoutApplicationsInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  baseUrl?: Maybe<String>;
  enabled?: Maybe<Boolean>;
  reportingProtocol?: Maybe<ReportingProtocolCreateOneWithoutApplicationsInput>;
  devices?: Maybe<DeviceCreateManyWithoutApplicationInput>;
}

export interface PasswordPolicyScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  ruleText?: Maybe<String>;
  ruleText_not?: Maybe<String>;
  ruleText_in?: Maybe<String[] | String>;
  ruleText_not_in?: Maybe<String[] | String>;
  ruleText_lt?: Maybe<String>;
  ruleText_lte?: Maybe<String>;
  ruleText_gt?: Maybe<String>;
  ruleText_gte?: Maybe<String>;
  ruleText_contains?: Maybe<String>;
  ruleText_not_contains?: Maybe<String>;
  ruleText_starts_with?: Maybe<String>;
  ruleText_not_starts_with?: Maybe<String>;
  ruleText_ends_with?: Maybe<String>;
  ruleText_not_ends_with?: Maybe<String>;
  ruleRegExp?: Maybe<String>;
  ruleRegExp_not?: Maybe<String>;
  ruleRegExp_in?: Maybe<String[] | String>;
  ruleRegExp_not_in?: Maybe<String[] | String>;
  ruleRegExp_lt?: Maybe<String>;
  ruleRegExp_lte?: Maybe<String>;
  ruleRegExp_gt?: Maybe<String>;
  ruleRegExp_gte?: Maybe<String>;
  ruleRegExp_contains?: Maybe<String>;
  ruleRegExp_not_contains?: Maybe<String>;
  ruleRegExp_starts_with?: Maybe<String>;
  ruleRegExp_not_starts_with?: Maybe<String>;
  ruleRegExp_ends_with?: Maybe<String>;
  ruleRegExp_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    PasswordPolicyScalarWhereInput[] | PasswordPolicyScalarWhereInput
  >;
  OR?: Maybe<PasswordPolicyScalarWhereInput[] | PasswordPolicyScalarWhereInput>;
  NOT?: Maybe<
    PasswordPolicyScalarWhereInput[] | PasswordPolicyScalarWhereInput
  >;
}

export interface ReportingProtocolCreateWithoutApplicationsInput {
  name?: Maybe<String>;
  protocolHandler?: Maybe<String>;
}

export interface PasswordPolicyUpdateManyWithWhereNestedInput {
  where: PasswordPolicyScalarWhereInput;
  data: PasswordPolicyUpdateManyDataInput;
}

export interface DeviceCreateWithoutApplicationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  deviceModel?: Maybe<String>;
  deviceNetworkTypeLinks?: Maybe<
    DeviceNetworkTypeLinkCreateManyWithoutDeviceInput
  >;
}

export interface PasswordPolicyUpdateManyDataInput {
  ruleText?: Maybe<String>;
  ruleRegExp?: Maybe<String>;
}

export interface DeviceNetworkTypeLinkCreateWithoutDeviceInput {
  networkType: NetworkTypeCreateOneWithoutDeviceNetworkTypeLinksInput;
  deviceProfile: DeviceProfileCreateOneWithoutDeviceNetworkTypeLinksInput;
  networkSettings?: Maybe<String>;
}

export interface UserUpdateManyWithoutCompanyInput {
  create?: Maybe<
    UserCreateWithoutCompanyInput[] | UserCreateWithoutCompanyInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutCompanyInput[]
    | UserUpdateWithWhereUniqueWithoutCompanyInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutCompanyInput[]
    | UserUpsertWithWhereUniqueWithoutCompanyInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface NetworkTypeCreateWithoutDeviceNetworkTypeLinksInput {
  name: String;
  applicationNetworkTypeLinks?: Maybe<
    ApplicationNetworkTypeLinkCreateManyWithoutNetworkTypeInput
  >;
  companyNetworkTypeLinks?: Maybe<
    CompanyNetworkTypeLinkCreateManyWithoutNetworkTypeInput
  >;
  deviceProfiles?: Maybe<DeviceProfileCreateManyWithoutNetworkTypeInput>;
  networkProtocols?: Maybe<NetworkProtocolCreateManyWithoutNetworkTypeInput>;
  networks?: Maybe<NetworkCreateManyWithoutNetworkTypeInput>;
}

export interface UserUpdateWithWhereUniqueWithoutCompanyInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutCompanyDataInput;
}

export interface CompanyNetworkTypeLinkCreateWithoutNetworkTypeInput {
  company: CompanyCreateOneWithoutCompanyNetworkTypeLinksInput;
  networkSettings?: Maybe<String>;
}

export interface UserUpdateWithoutCompanyDataInput {
  username?: Maybe<String>;
  email?: Maybe<String>;
  lastVerifiedEmail?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  passwordHash?: Maybe<String>;
  role?: Maybe<UserRoleUpdateOneRequiredWithoutUsersInput>;
  emailVerifications?: Maybe<EmailVerificationUpdateManyWithoutUserInput>;
}

export interface CompanyCreateWithoutCompanyNetworkTypeLinksInput {
  name?: Maybe<String>;
  type?: Maybe<CompanyTypeCreateOneWithoutCompaniesInput>;
  applications?: Maybe<ApplicationCreateManyWithoutCompanyInput>;
  deviceProfiles?: Maybe<DeviceProfileCreateManyWithoutCompanyInput>;
  passwordPolicies?: Maybe<PasswordPolicyCreateManyWithoutCompanyInput>;
  users?: Maybe<UserCreateManyWithoutCompanyInput>;
}

export interface UserRoleUpdateOneRequiredWithoutUsersInput {
  create?: Maybe<UserRoleCreateWithoutUsersInput>;
  update?: Maybe<UserRoleUpdateWithoutUsersDataInput>;
  upsert?: Maybe<UserRoleUpsertWithoutUsersInput>;
  connect?: Maybe<UserRoleWhereUniqueInput>;
}

export interface ApplicationCreateWithoutCompanyInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  baseUrl?: Maybe<String>;
  enabled?: Maybe<Boolean>;
  reportingProtocol?: Maybe<ReportingProtocolCreateOneWithoutApplicationsInput>;
  applicationNetworkTypeLinks?: Maybe<
    ApplicationNetworkTypeLinkCreateManyWithoutApplicationInput
  >;
  devices?: Maybe<DeviceCreateManyWithoutApplicationInput>;
}

export interface UserRoleUpdateWithoutUsersDataInput {
  name?: Maybe<String>;
}

export interface ApplicationNetworkTypeLinkCreateWithoutApplicationInput {
  networkType: NetworkTypeCreateOneWithoutApplicationNetworkTypeLinksInput;
  networkSettings?: Maybe<String>;
}

export interface UserRoleUpsertWithoutUsersInput {
  update: UserRoleUpdateWithoutUsersDataInput;
  create: UserRoleCreateWithoutUsersInput;
}

export interface NetworkTypeCreateWithoutApplicationNetworkTypeLinksInput {
  name: String;
  companyNetworkTypeLinks?: Maybe<
    CompanyNetworkTypeLinkCreateManyWithoutNetworkTypeInput
  >;
  deviceNetworkTypeLinks?: Maybe<
    DeviceNetworkTypeLinkCreateManyWithoutNetworkTypeInput
  >;
  deviceProfiles?: Maybe<DeviceProfileCreateManyWithoutNetworkTypeInput>;
  networkProtocols?: Maybe<NetworkProtocolCreateManyWithoutNetworkTypeInput>;
  networks?: Maybe<NetworkCreateManyWithoutNetworkTypeInput>;
}

export interface EmailVerificationUpdateManyWithoutUserInput {
  create?: Maybe<
    | EmailVerificationCreateWithoutUserInput[]
    | EmailVerificationCreateWithoutUserInput
  >;
  delete?: Maybe<
    EmailVerificationWhereUniqueInput[] | EmailVerificationWhereUniqueInput
  >;
  connect?: Maybe<
    EmailVerificationWhereUniqueInput[] | EmailVerificationWhereUniqueInput
  >;
  set?: Maybe<
    EmailVerificationWhereUniqueInput[] | EmailVerificationWhereUniqueInput
  >;
  disconnect?: Maybe<
    EmailVerificationWhereUniqueInput[] | EmailVerificationWhereUniqueInput
  >;
  update?: Maybe<
    | EmailVerificationUpdateWithWhereUniqueWithoutUserInput[]
    | EmailVerificationUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | EmailVerificationUpsertWithWhereUniqueWithoutUserInput[]
    | EmailVerificationUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    EmailVerificationScalarWhereInput[] | EmailVerificationScalarWhereInput
  >;
  updateMany?: Maybe<
    | EmailVerificationUpdateManyWithWhereNestedInput[]
    | EmailVerificationUpdateManyWithWhereNestedInput
  >;
}

export interface DeviceNetworkTypeLinkCreateWithoutNetworkTypeInput {
  device: DeviceCreateOneWithoutDeviceNetworkTypeLinksInput;
  deviceProfile: DeviceProfileCreateOneWithoutDeviceNetworkTypeLinksInput;
  networkSettings?: Maybe<String>;
}

export interface EmailVerificationUpdateWithWhereUniqueWithoutUserInput {
  where: EmailVerificationWhereUniqueInput;
  data: EmailVerificationUpdateWithoutUserDataInput;
}

export interface DeviceCreateWithoutDeviceNetworkTypeLinksInput {
  application: ApplicationCreateOneWithoutDevicesInput;
  name?: Maybe<String>;
  description?: Maybe<String>;
  deviceModel?: Maybe<String>;
}

export interface EmailVerificationUpdateWithoutUserDataInput {
  uuid?: Maybe<String>;
  email?: Maybe<String>;
  changeRequested?: Maybe<String>;
}

export interface ApplicationCreateWithoutDevicesInput {
  company?: Maybe<CompanyCreateOneWithoutApplicationsInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  baseUrl?: Maybe<String>;
  enabled?: Maybe<Boolean>;
  reportingProtocol?: Maybe<ReportingProtocolCreateOneWithoutApplicationsInput>;
  applicationNetworkTypeLinks?: Maybe<
    ApplicationNetworkTypeLinkCreateManyWithoutApplicationInput
  >;
}

export interface EmailVerificationUpsertWithWhereUniqueWithoutUserInput {
  where: EmailVerificationWhereUniqueInput;
  update: EmailVerificationUpdateWithoutUserDataInput;
  create: EmailVerificationCreateWithoutUserInput;
}

export interface DeviceProfileCreateWithoutDeviceNetworkTypeLinksInput {
  networkType: NetworkTypeCreateOneWithoutDeviceProfilesInput;
  company: CompanyCreateOneWithoutDeviceProfilesInput;
  name?: Maybe<String>;
  description?: Maybe<String>;
  networkSettings?: Maybe<String>;
}

export interface EmailVerificationScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  uuid?: Maybe<String>;
  uuid_not?: Maybe<String>;
  uuid_in?: Maybe<String[] | String>;
  uuid_not_in?: Maybe<String[] | String>;
  uuid_lt?: Maybe<String>;
  uuid_lte?: Maybe<String>;
  uuid_gt?: Maybe<String>;
  uuid_gte?: Maybe<String>;
  uuid_contains?: Maybe<String>;
  uuid_not_contains?: Maybe<String>;
  uuid_starts_with?: Maybe<String>;
  uuid_not_starts_with?: Maybe<String>;
  uuid_ends_with?: Maybe<String>;
  uuid_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  changeRequested?: Maybe<String>;
  changeRequested_not?: Maybe<String>;
  changeRequested_in?: Maybe<String[] | String>;
  changeRequested_not_in?: Maybe<String[] | String>;
  changeRequested_lt?: Maybe<String>;
  changeRequested_lte?: Maybe<String>;
  changeRequested_gt?: Maybe<String>;
  changeRequested_gte?: Maybe<String>;
  changeRequested_contains?: Maybe<String>;
  changeRequested_not_contains?: Maybe<String>;
  changeRequested_starts_with?: Maybe<String>;
  changeRequested_not_starts_with?: Maybe<String>;
  changeRequested_ends_with?: Maybe<String>;
  changeRequested_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    EmailVerificationScalarWhereInput[] | EmailVerificationScalarWhereInput
  >;
  OR?: Maybe<
    EmailVerificationScalarWhereInput[] | EmailVerificationScalarWhereInput
  >;
  NOT?: Maybe<
    EmailVerificationScalarWhereInput[] | EmailVerificationScalarWhereInput
  >;
}

export interface NetworkTypeCreateWithoutDeviceProfilesInput {
  name: String;
  applicationNetworkTypeLinks?: Maybe<
    ApplicationNetworkTypeLinkCreateManyWithoutNetworkTypeInput
  >;
  companyNetworkTypeLinks?: Maybe<
    CompanyNetworkTypeLinkCreateManyWithoutNetworkTypeInput
  >;
  deviceNetworkTypeLinks?: Maybe<
    DeviceNetworkTypeLinkCreateManyWithoutNetworkTypeInput
  >;
  networkProtocols?: Maybe<NetworkProtocolCreateManyWithoutNetworkTypeInput>;
  networks?: Maybe<NetworkCreateManyWithoutNetworkTypeInput>;
}

export interface EmailVerificationUpdateManyWithWhereNestedInput {
  where: EmailVerificationScalarWhereInput;
  data: EmailVerificationUpdateManyDataInput;
}

export interface NetworkProtocolCreateWithoutNetworkTypeInput {
  name?: Maybe<String>;
  protocolHandler?: Maybe<String>;
  networkProtocolVersion?: Maybe<String>;
  masterProtocol?: Maybe<Int>;
  networks?: Maybe<NetworkCreateManyWithoutNetworkProtocolInput>;
  protocolData?: Maybe<ProtocolDataCreateManyWithoutNetworkProtocolInput>;
}

export interface EmailVerificationUpdateManyDataInput {
  uuid?: Maybe<String>;
  email?: Maybe<String>;
  changeRequested?: Maybe<String>;
}

export interface NetworkCreateWithoutNetworkProtocolInput {
  name?: Maybe<String>;
  networkProvider?: Maybe<NetworkProviderCreateOneWithoutNetworksInput>;
  networkType: NetworkTypeCreateOneWithoutNetworksInput;
  baseUrl?: Maybe<String>;
  securityData?: Maybe<String>;
  protocolData?: Maybe<ProtocolDataCreateManyWithoutNetworkInput>;
}

export interface UserUpsertWithWhereUniqueWithoutCompanyInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutCompanyDataInput;
  create: UserCreateWithoutCompanyInput;
}

export interface NetworkProviderCreateWithoutNetworksInput {
  name?: Maybe<String>;
}

export interface UserScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  lastVerifiedEmail?: Maybe<String>;
  lastVerifiedEmail_not?: Maybe<String>;
  lastVerifiedEmail_in?: Maybe<String[] | String>;
  lastVerifiedEmail_not_in?: Maybe<String[] | String>;
  lastVerifiedEmail_lt?: Maybe<String>;
  lastVerifiedEmail_lte?: Maybe<String>;
  lastVerifiedEmail_gt?: Maybe<String>;
  lastVerifiedEmail_gte?: Maybe<String>;
  lastVerifiedEmail_contains?: Maybe<String>;
  lastVerifiedEmail_not_contains?: Maybe<String>;
  lastVerifiedEmail_starts_with?: Maybe<String>;
  lastVerifiedEmail_not_starts_with?: Maybe<String>;
  lastVerifiedEmail_ends_with?: Maybe<String>;
  lastVerifiedEmail_not_ends_with?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  emailVerified_not?: Maybe<Boolean>;
  passwordHash?: Maybe<String>;
  passwordHash_not?: Maybe<String>;
  passwordHash_in?: Maybe<String[] | String>;
  passwordHash_not_in?: Maybe<String[] | String>;
  passwordHash_lt?: Maybe<String>;
  passwordHash_lte?: Maybe<String>;
  passwordHash_gt?: Maybe<String>;
  passwordHash_gte?: Maybe<String>;
  passwordHash_contains?: Maybe<String>;
  passwordHash_not_contains?: Maybe<String>;
  passwordHash_starts_with?: Maybe<String>;
  passwordHash_not_starts_with?: Maybe<String>;
  passwordHash_ends_with?: Maybe<String>;
  passwordHash_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
}

export interface NetworkTypeCreateWithoutNetworksInput {
  name: String;
  applicationNetworkTypeLinks?: Maybe<
    ApplicationNetworkTypeLinkCreateManyWithoutNetworkTypeInput
  >;
  companyNetworkTypeLinks?: Maybe<
    CompanyNetworkTypeLinkCreateManyWithoutNetworkTypeInput
  >;
  deviceNetworkTypeLinks?: Maybe<
    DeviceNetworkTypeLinkCreateManyWithoutNetworkTypeInput
  >;
  deviceProfiles?: Maybe<DeviceProfileCreateManyWithoutNetworkTypeInput>;
  networkProtocols?: Maybe<NetworkProtocolCreateManyWithoutNetworkTypeInput>;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface DeviceProfileCreateWithoutNetworkTypeInput {
  company: CompanyCreateOneWithoutDeviceProfilesInput;
  name?: Maybe<String>;
  description?: Maybe<String>;
  networkSettings?: Maybe<String>;
  deviceNetworkTypeLinks?: Maybe<
    DeviceNetworkTypeLinkCreateManyWithoutDeviceProfileInput
  >;
}

export interface UserUpdateManyDataInput {
  username?: Maybe<String>;
  email?: Maybe<String>;
  lastVerifiedEmail?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  passwordHash?: Maybe<String>;
}

export interface CompanyCreateWithoutDeviceProfilesInput {
  name?: Maybe<String>;
  type?: Maybe<CompanyTypeCreateOneWithoutCompaniesInput>;
  applications?: Maybe<ApplicationCreateManyWithoutCompanyInput>;
  companyNetworkTypeLinks?: Maybe<
    CompanyNetworkTypeLinkCreateManyWithoutCompanyInput
  >;
  passwordPolicies?: Maybe<PasswordPolicyCreateManyWithoutCompanyInput>;
  users?: Maybe<UserCreateManyWithoutCompanyInput>;
}

export interface CompanyUpsertWithoutDeviceProfilesInput {
  update: CompanyUpdateWithoutDeviceProfilesDataInput;
  create: CompanyCreateWithoutDeviceProfilesInput;
}

export interface PasswordPolicyCreateWithoutCompanyInput {
  ruleText?: Maybe<String>;
  ruleRegExp?: Maybe<String>;
}

export interface DeviceNetworkTypeLinkUpdateManyWithoutDeviceProfileInput {
  create?: Maybe<
    | DeviceNetworkTypeLinkCreateWithoutDeviceProfileInput[]
    | DeviceNetworkTypeLinkCreateWithoutDeviceProfileInput
  >;
  delete?: Maybe<
    | DeviceNetworkTypeLinkWhereUniqueInput[]
    | DeviceNetworkTypeLinkWhereUniqueInput
  >;
  connect?: Maybe<
    | DeviceNetworkTypeLinkWhereUniqueInput[]
    | DeviceNetworkTypeLinkWhereUniqueInput
  >;
  set?: Maybe<
    | DeviceNetworkTypeLinkWhereUniqueInput[]
    | DeviceNetworkTypeLinkWhereUniqueInput
  >;
  disconnect?: Maybe<
    | DeviceNetworkTypeLinkWhereUniqueInput[]
    | DeviceNetworkTypeLinkWhereUniqueInput
  >;
  update?: Maybe<
    | DeviceNetworkTypeLinkUpdateWithWhereUniqueWithoutDeviceProfileInput[]
    | DeviceNetworkTypeLinkUpdateWithWhereUniqueWithoutDeviceProfileInput
  >;
  upsert?: Maybe<
    | DeviceNetworkTypeLinkUpsertWithWhereUniqueWithoutDeviceProfileInput[]
    | DeviceNetworkTypeLinkUpsertWithWhereUniqueWithoutDeviceProfileInput
  >;
  deleteMany?: Maybe<
    | DeviceNetworkTypeLinkScalarWhereInput[]
    | DeviceNetworkTypeLinkScalarWhereInput
  >;
  updateMany?: Maybe<
    | DeviceNetworkTypeLinkUpdateManyWithWhereNestedInput[]
    | DeviceNetworkTypeLinkUpdateManyWithWhereNestedInput
  >;
}

export interface UserCreateWithoutCompanyInput {
  username?: Maybe<String>;
  email?: Maybe<String>;
  lastVerifiedEmail?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  passwordHash: String;
  role: UserRoleCreateOneWithoutUsersInput;
  emailVerifications?: Maybe<EmailVerificationCreateManyWithoutUserInput>;
}

export interface DeviceNetworkTypeLinkUpdateWithWhereUniqueWithoutDeviceProfileInput {
  where: DeviceNetworkTypeLinkWhereUniqueInput;
  data: DeviceNetworkTypeLinkUpdateWithoutDeviceProfileDataInput;
}

export interface UserRoleCreateWithoutUsersInput {
  name?: Maybe<String>;
}

export interface DeviceNetworkTypeLinkUpdateWithoutDeviceProfileDataInput {
  device?: Maybe<DeviceUpdateOneRequiredWithoutDeviceNetworkTypeLinksInput>;
  networkType?: Maybe<
    NetworkTypeUpdateOneRequiredWithoutDeviceNetworkTypeLinksInput
  >;
  networkSettings?: Maybe<String>;
}

export interface EmailVerificationCreateWithoutUserInput {
  uuid?: Maybe<String>;
  email?: Maybe<String>;
  changeRequested?: Maybe<String>;
}

export interface DeviceNetworkTypeLinkUpsertWithWhereUniqueWithoutDeviceProfileInput {
  where: DeviceNetworkTypeLinkWhereUniqueInput;
  update: DeviceNetworkTypeLinkUpdateWithoutDeviceProfileDataInput;
  create: DeviceNetworkTypeLinkCreateWithoutDeviceProfileInput;
}

export interface DeviceNetworkTypeLinkCreateWithoutDeviceProfileInput {
  device: DeviceCreateOneWithoutDeviceNetworkTypeLinksInput;
  networkType: NetworkTypeCreateOneWithoutDeviceNetworkTypeLinksInput;
  networkSettings?: Maybe<String>;
}

export interface DeviceNetworkTypeLinkScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  networkSettings?: Maybe<String>;
  networkSettings_not?: Maybe<String>;
  networkSettings_in?: Maybe<String[] | String>;
  networkSettings_not_in?: Maybe<String[] | String>;
  networkSettings_lt?: Maybe<String>;
  networkSettings_lte?: Maybe<String>;
  networkSettings_gt?: Maybe<String>;
  networkSettings_gte?: Maybe<String>;
  networkSettings_contains?: Maybe<String>;
  networkSettings_not_contains?: Maybe<String>;
  networkSettings_starts_with?: Maybe<String>;
  networkSettings_not_starts_with?: Maybe<String>;
  networkSettings_ends_with?: Maybe<String>;
  networkSettings_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    | DeviceNetworkTypeLinkScalarWhereInput[]
    | DeviceNetworkTypeLinkScalarWhereInput
  >;
  OR?: Maybe<
    | DeviceNetworkTypeLinkScalarWhereInput[]
    | DeviceNetworkTypeLinkScalarWhereInput
  >;
  NOT?: Maybe<
    | DeviceNetworkTypeLinkScalarWhereInput[]
    | DeviceNetworkTypeLinkScalarWhereInput
  >;
}

export interface ProtocolDataCreateWithoutNetworkInput {
  networkProtocol: NetworkProtocolCreateOneWithoutProtocolDataInput;
  dataIdentifier?: Maybe<String>;
  dataValue?: Maybe<String>;
}

export interface DeviceNetworkTypeLinkUpdateManyWithWhereNestedInput {
  where: DeviceNetworkTypeLinkScalarWhereInput;
  data: DeviceNetworkTypeLinkUpdateManyDataInput;
}

export interface NetworkProtocolCreateWithoutProtocolDataInput {
  name?: Maybe<String>;
  protocolHandler?: Maybe<String>;
  networkType: NetworkTypeCreateOneWithoutNetworkProtocolsInput;
  networkProtocolVersion?: Maybe<String>;
  masterProtocol?: Maybe<Int>;
  networks?: Maybe<NetworkCreateManyWithoutNetworkProtocolInput>;
}

export interface DeviceNetworkTypeLinkUpdateManyDataInput {
  networkSettings?: Maybe<String>;
}

export interface NetworkTypeCreateWithoutNetworkProtocolsInput {
  name: String;
  applicationNetworkTypeLinks?: Maybe<
    ApplicationNetworkTypeLinkCreateManyWithoutNetworkTypeInput
  >;
  companyNetworkTypeLinks?: Maybe<
    CompanyNetworkTypeLinkCreateManyWithoutNetworkTypeInput
  >;
  deviceNetworkTypeLinks?: Maybe<
    DeviceNetworkTypeLinkCreateManyWithoutNetworkTypeInput
  >;
  deviceProfiles?: Maybe<DeviceProfileCreateManyWithoutNetworkTypeInput>;
  networks?: Maybe<NetworkCreateManyWithoutNetworkTypeInput>;
}

export interface DeviceProfileUpsertWithWhereUniqueWithoutNetworkTypeInput {
  where: DeviceProfileWhereUniqueInput;
  update: DeviceProfileUpdateWithoutNetworkTypeDataInput;
  create: DeviceProfileCreateWithoutNetworkTypeInput;
}

export interface NetworkCreateWithoutNetworkTypeInput {
  name?: Maybe<String>;
  networkProvider?: Maybe<NetworkProviderCreateOneWithoutNetworksInput>;
  networkProtocol: NetworkProtocolCreateOneWithoutNetworksInput;
  baseUrl?: Maybe<String>;
  securityData?: Maybe<String>;
  protocolData?: Maybe<ProtocolDataCreateManyWithoutNetworkInput>;
}

export interface DeviceProfileScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  networkSettings?: Maybe<String>;
  networkSettings_not?: Maybe<String>;
  networkSettings_in?: Maybe<String[] | String>;
  networkSettings_not_in?: Maybe<String[] | String>;
  networkSettings_lt?: Maybe<String>;
  networkSettings_lte?: Maybe<String>;
  networkSettings_gt?: Maybe<String>;
  networkSettings_gte?: Maybe<String>;
  networkSettings_contains?: Maybe<String>;
  networkSettings_not_contains?: Maybe<String>;
  networkSettings_starts_with?: Maybe<String>;
  networkSettings_not_starts_with?: Maybe<String>;
  networkSettings_ends_with?: Maybe<String>;
  networkSettings_not_ends_with?: Maybe<String>;
  AND?: Maybe<DeviceProfileScalarWhereInput[] | DeviceProfileScalarWhereInput>;
  OR?: Maybe<DeviceProfileScalarWhereInput[] | DeviceProfileScalarWhereInput>;
  NOT?: Maybe<DeviceProfileScalarWhereInput[] | DeviceProfileScalarWhereInput>;
}

export interface NetworkProtocolCreateWithoutNetworksInput {
  name?: Maybe<String>;
  protocolHandler?: Maybe<String>;
  networkType: NetworkTypeCreateOneWithoutNetworkProtocolsInput;
  networkProtocolVersion?: Maybe<String>;
  masterProtocol?: Maybe<Int>;
  protocolData?: Maybe<ProtocolDataCreateManyWithoutNetworkProtocolInput>;
}

export interface DeviceProfileUpdateManyWithWhereNestedInput {
  where: DeviceProfileScalarWhereInput;
  data: DeviceProfileUpdateManyDataInput;
}

export interface ProtocolDataCreateWithoutNetworkProtocolInput {
  network: NetworkCreateOneWithoutProtocolDataInput;
  dataIdentifier?: Maybe<String>;
  dataValue?: Maybe<String>;
}

export interface DeviceProfileUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  networkSettings?: Maybe<String>;
}

export interface NetworkCreateWithoutProtocolDataInput {
  name?: Maybe<String>;
  networkProvider?: Maybe<NetworkProviderCreateOneWithoutNetworksInput>;
  networkType: NetworkTypeCreateOneWithoutNetworksInput;
  networkProtocol: NetworkProtocolCreateOneWithoutNetworksInput;
  baseUrl?: Maybe<String>;
  securityData?: Maybe<String>;
}

export interface NetworkTypeUpsertWithoutNetworksInput {
  update: NetworkTypeUpdateWithoutNetworksDataInput;
  create: NetworkTypeCreateWithoutNetworksInput;
}

export interface DeviceProfileCreateWithoutCompanyInput {
  networkType: NetworkTypeCreateOneWithoutDeviceProfilesInput;
  name?: Maybe<String>;
  description?: Maybe<String>;
  networkSettings?: Maybe<String>;
  deviceNetworkTypeLinks?: Maybe<
    DeviceNetworkTypeLinkCreateManyWithoutDeviceProfileInput
  >;
}

export interface ProtocolDataUpdateManyWithoutNetworkInput {
  create?: Maybe<
    | ProtocolDataCreateWithoutNetworkInput[]
    | ProtocolDataCreateWithoutNetworkInput
  >;
  delete?: Maybe<ProtocolDataWhereUniqueInput[] | ProtocolDataWhereUniqueInput>;
  connect?: Maybe<
    ProtocolDataWhereUniqueInput[] | ProtocolDataWhereUniqueInput
  >;
  set?: Maybe<ProtocolDataWhereUniqueInput[] | ProtocolDataWhereUniqueInput>;
  disconnect?: Maybe<
    ProtocolDataWhereUniqueInput[] | ProtocolDataWhereUniqueInput
  >;
  update?: Maybe<
    | ProtocolDataUpdateWithWhereUniqueWithoutNetworkInput[]
    | ProtocolDataUpdateWithWhereUniqueWithoutNetworkInput
  >;
  upsert?: Maybe<
    | ProtocolDataUpsertWithWhereUniqueWithoutNetworkInput[]
    | ProtocolDataUpsertWithWhereUniqueWithoutNetworkInput
  >;
  deleteMany?: Maybe<
    ProtocolDataScalarWhereInput[] | ProtocolDataScalarWhereInput
  >;
  updateMany?: Maybe<
    | ProtocolDataUpdateManyWithWhereNestedInput[]
    | ProtocolDataUpdateManyWithWhereNestedInput
  >;
}

export interface CompanyUpdateOneWithoutApplicationsInput {
  create?: Maybe<CompanyCreateWithoutApplicationsInput>;
  update?: Maybe<CompanyUpdateWithoutApplicationsDataInput>;
  upsert?: Maybe<CompanyUpsertWithoutApplicationsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface ProtocolDataUpdateWithWhereUniqueWithoutNetworkInput {
  where: ProtocolDataWhereUniqueInput;
  data: ProtocolDataUpdateWithoutNetworkDataInput;
}

export interface CompanyTypeUpdateOneWithoutCompaniesInput {
  create?: Maybe<CompanyTypeCreateWithoutCompaniesInput>;
  update?: Maybe<CompanyTypeUpdateWithoutCompaniesDataInput>;
  upsert?: Maybe<CompanyTypeUpsertWithoutCompaniesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CompanyTypeWhereUniqueInput>;
}

export interface ProtocolDataUpdateWithoutNetworkDataInput {
  networkProtocol?: Maybe<
    NetworkProtocolUpdateOneRequiredWithoutProtocolDataInput
  >;
  dataIdentifier?: Maybe<String>;
  dataValue?: Maybe<String>;
}

export interface CompanyTypeUpsertWithoutCompaniesInput {
  update: CompanyTypeUpdateWithoutCompaniesDataInput;
  create: CompanyTypeCreateWithoutCompaniesInput;
}

export interface NetworkProtocolUpdateOneRequiredWithoutProtocolDataInput {
  create?: Maybe<NetworkProtocolCreateWithoutProtocolDataInput>;
  update?: Maybe<NetworkProtocolUpdateWithoutProtocolDataDataInput>;
  upsert?: Maybe<NetworkProtocolUpsertWithoutProtocolDataInput>;
  connect?: Maybe<NetworkProtocolWhereUniqueInput>;
}

export interface CompanyNetworkTypeLinkUpdateWithWhereUniqueWithoutCompanyInput {
  where: CompanyNetworkTypeLinkWhereUniqueInput;
  data: CompanyNetworkTypeLinkUpdateWithoutCompanyDataInput;
}

export interface NetworkProtocolUpdateWithoutProtocolDataDataInput {
  name?: Maybe<String>;
  protocolHandler?: Maybe<String>;
  networkType?: Maybe<NetworkTypeUpdateOneRequiredWithoutNetworkProtocolsInput>;
  networkProtocolVersion?: Maybe<String>;
  masterProtocol?: Maybe<Int>;
  networks?: Maybe<NetworkUpdateManyWithoutNetworkProtocolInput>;
}

export interface NetworkTypeUpdateOneRequiredWithoutCompanyNetworkTypeLinksInput {
  create?: Maybe<NetworkTypeCreateWithoutCompanyNetworkTypeLinksInput>;
  update?: Maybe<NetworkTypeUpdateWithoutCompanyNetworkTypeLinksDataInput>;
  upsert?: Maybe<NetworkTypeUpsertWithoutCompanyNetworkTypeLinksInput>;
  connect?: Maybe<NetworkTypeWhereUniqueInput>;
}

export interface NetworkTypeUpdateOneRequiredWithoutNetworkProtocolsInput {
  create?: Maybe<NetworkTypeCreateWithoutNetworkProtocolsInput>;
  update?: Maybe<NetworkTypeUpdateWithoutNetworkProtocolsDataInput>;
  upsert?: Maybe<NetworkTypeUpsertWithoutNetworkProtocolsInput>;
  connect?: Maybe<NetworkTypeWhereUniqueInput>;
}

export interface ApplicationNetworkTypeLinkUpdateManyWithoutNetworkTypeInput {
  create?: Maybe<
    | ApplicationNetworkTypeLinkCreateWithoutNetworkTypeInput[]
    | ApplicationNetworkTypeLinkCreateWithoutNetworkTypeInput
  >;
  delete?: Maybe<
    | ApplicationNetworkTypeLinkWhereUniqueInput[]
    | ApplicationNetworkTypeLinkWhereUniqueInput
  >;
  connect?: Maybe<
    | ApplicationNetworkTypeLinkWhereUniqueInput[]
    | ApplicationNetworkTypeLinkWhereUniqueInput
  >;
  set?: Maybe<
    | ApplicationNetworkTypeLinkWhereUniqueInput[]
    | ApplicationNetworkTypeLinkWhereUniqueInput
  >;
  disconnect?: Maybe<
    | ApplicationNetworkTypeLinkWhereUniqueInput[]
    | ApplicationNetworkTypeLinkWhereUniqueInput
  >;
  update?: Maybe<
    | ApplicationNetworkTypeLinkUpdateWithWhereUniqueWithoutNetworkTypeInput[]
    | ApplicationNetworkTypeLinkUpdateWithWhereUniqueWithoutNetworkTypeInput
  >;
  upsert?: Maybe<
    | ApplicationNetworkTypeLinkUpsertWithWhereUniqueWithoutNetworkTypeInput[]
    | ApplicationNetworkTypeLinkUpsertWithWhereUniqueWithoutNetworkTypeInput
  >;
  deleteMany?: Maybe<
    | ApplicationNetworkTypeLinkScalarWhereInput[]
    | ApplicationNetworkTypeLinkScalarWhereInput
  >;
  updateMany?: Maybe<
    | ApplicationNetworkTypeLinkUpdateManyWithWhereNestedInput[]
    | ApplicationNetworkTypeLinkUpdateManyWithWhereNestedInput
  >;
}

export interface NetworkTypeUpdateWithoutNetworkProtocolsDataInput {
  name?: Maybe<String>;
  applicationNetworkTypeLinks?: Maybe<
    ApplicationNetworkTypeLinkUpdateManyWithoutNetworkTypeInput
  >;
  companyNetworkTypeLinks?: Maybe<
    CompanyNetworkTypeLinkUpdateManyWithoutNetworkTypeInput
  >;
  deviceNetworkTypeLinks?: Maybe<
    DeviceNetworkTypeLinkUpdateManyWithoutNetworkTypeInput
  >;
  deviceProfiles?: Maybe<DeviceProfileUpdateManyWithoutNetworkTypeInput>;
  networks?: Maybe<NetworkUpdateManyWithoutNetworkTypeInput>;
}

export interface ApplicationNetworkTypeLinkUpdateWithoutNetworkTypeDataInput {
  application?: Maybe<
    ApplicationUpdateOneRequiredWithoutApplicationNetworkTypeLinksInput
  >;
  networkSettings?: Maybe<String>;
}

export interface NetworkUpdateManyWithoutNetworkTypeInput {
  create?: Maybe<
    | NetworkCreateWithoutNetworkTypeInput[]
    | NetworkCreateWithoutNetworkTypeInput
  >;
  delete?: Maybe<NetworkWhereUniqueInput[] | NetworkWhereUniqueInput>;
  connect?: Maybe<NetworkWhereUniqueInput[] | NetworkWhereUniqueInput>;
  set?: Maybe<NetworkWhereUniqueInput[] | NetworkWhereUniqueInput>;
  disconnect?: Maybe<NetworkWhereUniqueInput[] | NetworkWhereUniqueInput>;
  update?: Maybe<
    | NetworkUpdateWithWhereUniqueWithoutNetworkTypeInput[]
    | NetworkUpdateWithWhereUniqueWithoutNetworkTypeInput
  >;
  upsert?: Maybe<
    | NetworkUpsertWithWhereUniqueWithoutNetworkTypeInput[]
    | NetworkUpsertWithWhereUniqueWithoutNetworkTypeInput
  >;
  deleteMany?: Maybe<NetworkScalarWhereInput[] | NetworkScalarWhereInput>;
  updateMany?: Maybe<
    | NetworkUpdateManyWithWhereNestedInput[]
    | NetworkUpdateManyWithWhereNestedInput
  >;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface NetworkUpdateWithWhereUniqueWithoutNetworkTypeInput {
  where: NetworkWhereUniqueInput;
  data: NetworkUpdateWithoutNetworkTypeDataInput;
}

export interface DeviceNetworkTypeLinkWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  device?: Maybe<DeviceWhereInput>;
  networkType?: Maybe<NetworkTypeWhereInput>;
  deviceProfile?: Maybe<DeviceProfileWhereInput>;
  networkSettings?: Maybe<String>;
  networkSettings_not?: Maybe<String>;
  networkSettings_in?: Maybe<String[] | String>;
  networkSettings_not_in?: Maybe<String[] | String>;
  networkSettings_lt?: Maybe<String>;
  networkSettings_lte?: Maybe<String>;
  networkSettings_gt?: Maybe<String>;
  networkSettings_gte?: Maybe<String>;
  networkSettings_contains?: Maybe<String>;
  networkSettings_not_contains?: Maybe<String>;
  networkSettings_starts_with?: Maybe<String>;
  networkSettings_not_starts_with?: Maybe<String>;
  networkSettings_ends_with?: Maybe<String>;
  networkSettings_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    DeviceNetworkTypeLinkWhereInput[] | DeviceNetworkTypeLinkWhereInput
  >;
  OR?: Maybe<
    DeviceNetworkTypeLinkWhereInput[] | DeviceNetworkTypeLinkWhereInput
  >;
  NOT?: Maybe<
    DeviceNetworkTypeLinkWhereInput[] | DeviceNetworkTypeLinkWhereInput
  >;
}

export interface NetworkUpdateWithoutNetworkTypeDataInput {
  name?: Maybe<String>;
  networkProvider?: Maybe<NetworkProviderUpdateOneWithoutNetworksInput>;
  networkProtocol?: Maybe<NetworkProtocolUpdateOneRequiredWithoutNetworksInput>;
  baseUrl?: Maybe<String>;
  securityData?: Maybe<String>;
  protocolData?: Maybe<ProtocolDataUpdateManyWithoutNetworkInput>;
}

export interface NetworkProviderSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<NetworkProviderWhereInput>;
  AND?: Maybe<
    | NetworkProviderSubscriptionWhereInput[]
    | NetworkProviderSubscriptionWhereInput
  >;
  OR?: Maybe<
    | NetworkProviderSubscriptionWhereInput[]
    | NetworkProviderSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | NetworkProviderSubscriptionWhereInput[]
    | NetworkProviderSubscriptionWhereInput
  >;
}

export interface NetworkProtocolUpdateOneRequiredWithoutNetworksInput {
  create?: Maybe<NetworkProtocolCreateWithoutNetworksInput>;
  update?: Maybe<NetworkProtocolUpdateWithoutNetworksDataInput>;
  upsert?: Maybe<NetworkProtocolUpsertWithoutNetworksInput>;
  connect?: Maybe<NetworkProtocolWhereUniqueInput>;
}

export interface NetworkSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<NetworkWhereInput>;
  AND?: Maybe<NetworkSubscriptionWhereInput[] | NetworkSubscriptionWhereInput>;
  OR?: Maybe<NetworkSubscriptionWhereInput[] | NetworkSubscriptionWhereInput>;
  NOT?: Maybe<NetworkSubscriptionWhereInput[] | NetworkSubscriptionWhereInput>;
}

export interface NetworkProtocolUpdateWithoutNetworksDataInput {
  name?: Maybe<String>;
  protocolHandler?: Maybe<String>;
  networkType?: Maybe<NetworkTypeUpdateOneRequiredWithoutNetworkProtocolsInput>;
  networkProtocolVersion?: Maybe<String>;
  masterProtocol?: Maybe<Int>;
  protocolData?: Maybe<ProtocolDataUpdateManyWithoutNetworkProtocolInput>;
}

export interface DeviceNetworkTypeLinkSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DeviceNetworkTypeLinkWhereInput>;
  AND?: Maybe<
    | DeviceNetworkTypeLinkSubscriptionWhereInput[]
    | DeviceNetworkTypeLinkSubscriptionWhereInput
  >;
  OR?: Maybe<
    | DeviceNetworkTypeLinkSubscriptionWhereInput[]
    | DeviceNetworkTypeLinkSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | DeviceNetworkTypeLinkSubscriptionWhereInput[]
    | DeviceNetworkTypeLinkSubscriptionWhereInput
  >;
}

export interface ProtocolDataUpdateManyWithoutNetworkProtocolInput {
  create?: Maybe<
    | ProtocolDataCreateWithoutNetworkProtocolInput[]
    | ProtocolDataCreateWithoutNetworkProtocolInput
  >;
  delete?: Maybe<ProtocolDataWhereUniqueInput[] | ProtocolDataWhereUniqueInput>;
  connect?: Maybe<
    ProtocolDataWhereUniqueInput[] | ProtocolDataWhereUniqueInput
  >;
  set?: Maybe<ProtocolDataWhereUniqueInput[] | ProtocolDataWhereUniqueInput>;
  disconnect?: Maybe<
    ProtocolDataWhereUniqueInput[] | ProtocolDataWhereUniqueInput
  >;
  update?: Maybe<
    | ProtocolDataUpdateWithWhereUniqueWithoutNetworkProtocolInput[]
    | ProtocolDataUpdateWithWhereUniqueWithoutNetworkProtocolInput
  >;
  upsert?: Maybe<
    | ProtocolDataUpsertWithWhereUniqueWithoutNetworkProtocolInput[]
    | ProtocolDataUpsertWithWhereUniqueWithoutNetworkProtocolInput
  >;
  deleteMany?: Maybe<
    ProtocolDataScalarWhereInput[] | ProtocolDataScalarWhereInput
  >;
  updateMany?: Maybe<
    | ProtocolDataUpdateManyWithWhereNestedInput[]
    | ProtocolDataUpdateManyWithWhereNestedInput
  >;
}

export interface CompanyNetworkTypeLinkSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CompanyNetworkTypeLinkWhereInput>;
  AND?: Maybe<
    | CompanyNetworkTypeLinkSubscriptionWhereInput[]
    | CompanyNetworkTypeLinkSubscriptionWhereInput
  >;
  OR?: Maybe<
    | CompanyNetworkTypeLinkSubscriptionWhereInput[]
    | CompanyNetworkTypeLinkSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CompanyNetworkTypeLinkSubscriptionWhereInput[]
    | CompanyNetworkTypeLinkSubscriptionWhereInput
  >;
}

export interface ProtocolDataUpdateWithWhereUniqueWithoutNetworkProtocolInput {
  where: ProtocolDataWhereUniqueInput;
  data: ProtocolDataUpdateWithoutNetworkProtocolDataInput;
}

export type ApplicationNetworkTypeLinkWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface ProtocolDataUpdateWithoutNetworkProtocolDataInput {
  network?: Maybe<NetworkUpdateOneRequiredWithoutProtocolDataInput>;
  dataIdentifier?: Maybe<String>;
  dataValue?: Maybe<String>;
}

export type CompanyWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
  name?: Maybe<String>;
}>;

export interface NetworkUpdateOneRequiredWithoutProtocolDataInput {
  create?: Maybe<NetworkCreateWithoutProtocolDataInput>;
  update?: Maybe<NetworkUpdateWithoutProtocolDataDataInput>;
  upsert?: Maybe<NetworkUpsertWithoutProtocolDataInput>;
  connect?: Maybe<NetworkWhereUniqueInput>;
}

export type CompanyNetworkTypeLinkWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface NetworkUpdateWithoutProtocolDataDataInput {
  name?: Maybe<String>;
  networkProvider?: Maybe<NetworkProviderUpdateOneWithoutNetworksInput>;
  networkType?: Maybe<NetworkTypeUpdateOneRequiredWithoutNetworksInput>;
  networkProtocol?: Maybe<NetworkProtocolUpdateOneRequiredWithoutNetworksInput>;
  baseUrl?: Maybe<String>;
  securityData?: Maybe<String>;
}

export type CompanyTypeWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
  name?: Maybe<String>;
}>;

export interface NetworkUpsertWithoutProtocolDataInput {
  update: NetworkUpdateWithoutProtocolDataDataInput;
  create: NetworkCreateWithoutProtocolDataInput;
}

export interface UserCreateInput {
  username?: Maybe<String>;
  email?: Maybe<String>;
  lastVerifiedEmail?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  company: CompanyCreateOneWithoutUsersInput;
  passwordHash: String;
  role: UserRoleCreateOneWithoutUsersInput;
  emailVerifications?: Maybe<EmailVerificationCreateManyWithoutUserInput>;
}

export interface ProtocolDataUpsertWithWhereUniqueWithoutNetworkProtocolInput {
  where: ProtocolDataWhereUniqueInput;
  update: ProtocolDataUpdateWithoutNetworkProtocolDataInput;
  create: ProtocolDataCreateWithoutNetworkProtocolInput;
}

export interface ApplicationUpdateWithoutReportingProtocolDataInput {
  company?: Maybe<CompanyUpdateOneWithoutApplicationsInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  baseUrl?: Maybe<String>;
  enabled?: Maybe<Boolean>;
  applicationNetworkTypeLinks?: Maybe<
    ApplicationNetworkTypeLinkUpdateManyWithoutApplicationInput
  >;
  devices?: Maybe<DeviceUpdateManyWithoutApplicationInput>;
}

export interface ProtocolDataScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  dataIdentifier?: Maybe<String>;
  dataIdentifier_not?: Maybe<String>;
  dataIdentifier_in?: Maybe<String[] | String>;
  dataIdentifier_not_in?: Maybe<String[] | String>;
  dataIdentifier_lt?: Maybe<String>;
  dataIdentifier_lte?: Maybe<String>;
  dataIdentifier_gt?: Maybe<String>;
  dataIdentifier_gte?: Maybe<String>;
  dataIdentifier_contains?: Maybe<String>;
  dataIdentifier_not_contains?: Maybe<String>;
  dataIdentifier_starts_with?: Maybe<String>;
  dataIdentifier_not_starts_with?: Maybe<String>;
  dataIdentifier_ends_with?: Maybe<String>;
  dataIdentifier_not_ends_with?: Maybe<String>;
  dataValue?: Maybe<String>;
  dataValue_not?: Maybe<String>;
  dataValue_in?: Maybe<String[] | String>;
  dataValue_not_in?: Maybe<String[] | String>;
  dataValue_lt?: Maybe<String>;
  dataValue_lte?: Maybe<String>;
  dataValue_gt?: Maybe<String>;
  dataValue_gte?: Maybe<String>;
  dataValue_contains?: Maybe<String>;
  dataValue_not_contains?: Maybe<String>;
  dataValue_starts_with?: Maybe<String>;
  dataValue_not_starts_with?: Maybe<String>;
  dataValue_ends_with?: Maybe<String>;
  dataValue_not_ends_with?: Maybe<String>;
  AND?: Maybe<ProtocolDataScalarWhereInput[] | ProtocolDataScalarWhereInput>;
  OR?: Maybe<ProtocolDataScalarWhereInput[] | ProtocolDataScalarWhereInput>;
  NOT?: Maybe<ProtocolDataScalarWhereInput[] | ProtocolDataScalarWhereInput>;
}

export interface ReportingProtocolUpdateInput {
  name?: Maybe<String>;
  protocolHandler?: Maybe<String>;
  applications?: Maybe<ApplicationUpdateManyWithoutReportingProtocolInput>;
}

export interface ProtocolDataUpdateManyWithWhereNestedInput {
  where: ProtocolDataScalarWhereInput;
  data: ProtocolDataUpdateManyDataInput;
}

export interface ReportingProtocolCreateInput {
  name?: Maybe<String>;
  protocolHandler?: Maybe<String>;
  applications?: Maybe<ApplicationCreateManyWithoutReportingProtocolInput>;
}

export interface ProtocolDataUpdateManyDataInput {
  dataIdentifier?: Maybe<String>;
  dataValue?: Maybe<String>;
}

export interface ProtocolDataCreateInput {
  network: NetworkCreateOneWithoutProtocolDataInput;
  networkProtocol: NetworkProtocolCreateOneWithoutProtocolDataInput;
  dataIdentifier?: Maybe<String>;
  dataValue?: Maybe<String>;
}

export interface NetworkProtocolUpsertWithoutNetworksInput {
  update: NetworkProtocolUpdateWithoutNetworksDataInput;
  create: NetworkProtocolCreateWithoutNetworksInput;
}

export interface CompanyUpdateWithoutPasswordPoliciesDataInput {
  name?: Maybe<String>;
  type?: Maybe<CompanyTypeUpdateOneWithoutCompaniesInput>;
  applications?: Maybe<ApplicationUpdateManyWithoutCompanyInput>;
  companyNetworkTypeLinks?: Maybe<
    CompanyNetworkTypeLinkUpdateManyWithoutCompanyInput
  >;
  deviceProfiles?: Maybe<DeviceProfileUpdateManyWithoutCompanyInput>;
  users?: Maybe<UserUpdateManyWithoutCompanyInput>;
}

export interface NetworkUpsertWithWhereUniqueWithoutNetworkTypeInput {
  where: NetworkWhereUniqueInput;
  update: NetworkUpdateWithoutNetworkTypeDataInput;
  create: NetworkCreateWithoutNetworkTypeInput;
}

export interface CompanyCreateWithoutPasswordPoliciesInput {
  name?: Maybe<String>;
  type?: Maybe<CompanyTypeCreateOneWithoutCompaniesInput>;
  applications?: Maybe<ApplicationCreateManyWithoutCompanyInput>;
  companyNetworkTypeLinks?: Maybe<
    CompanyNetworkTypeLinkCreateManyWithoutCompanyInput
  >;
  deviceProfiles?: Maybe<DeviceProfileCreateManyWithoutCompanyInput>;
  users?: Maybe<UserCreateManyWithoutCompanyInput>;
}

export interface NetworkScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  baseUrl?: Maybe<String>;
  baseUrl_not?: Maybe<String>;
  baseUrl_in?: Maybe<String[] | String>;
  baseUrl_not_in?: Maybe<String[] | String>;
  baseUrl_lt?: Maybe<String>;
  baseUrl_lte?: Maybe<String>;
  baseUrl_gt?: Maybe<String>;
  baseUrl_gte?: Maybe<String>;
  baseUrl_contains?: Maybe<String>;
  baseUrl_not_contains?: Maybe<String>;
  baseUrl_starts_with?: Maybe<String>;
  baseUrl_not_starts_with?: Maybe<String>;
  baseUrl_ends_with?: Maybe<String>;
  baseUrl_not_ends_with?: Maybe<String>;
  securityData?: Maybe<String>;
  securityData_not?: Maybe<String>;
  securityData_in?: Maybe<String[] | String>;
  securityData_not_in?: Maybe<String[] | String>;
  securityData_lt?: Maybe<String>;
  securityData_lte?: Maybe<String>;
  securityData_gt?: Maybe<String>;
  securityData_gte?: Maybe<String>;
  securityData_contains?: Maybe<String>;
  securityData_not_contains?: Maybe<String>;
  securityData_starts_with?: Maybe<String>;
  securityData_not_starts_with?: Maybe<String>;
  securityData_ends_with?: Maybe<String>;
  securityData_not_ends_with?: Maybe<String>;
  AND?: Maybe<NetworkScalarWhereInput[] | NetworkScalarWhereInput>;
  OR?: Maybe<NetworkScalarWhereInput[] | NetworkScalarWhereInput>;
  NOT?: Maybe<NetworkScalarWhereInput[] | NetworkScalarWhereInput>;
}

export interface PasswordPolicyCreateInput {
  ruleText?: Maybe<String>;
  ruleRegExp?: Maybe<String>;
  company?: Maybe<CompanyCreateOneWithoutPasswordPoliciesInput>;
}

export interface NetworkUpdateManyWithWhereNestedInput {
  where: NetworkScalarWhereInput;
  data: NetworkUpdateManyDataInput;
}

export interface NetworkTypeCreateInput {
  name: String;
  applicationNetworkTypeLinks?: Maybe<
    ApplicationNetworkTypeLinkCreateManyWithoutNetworkTypeInput
  >;
  companyNetworkTypeLinks?: Maybe<
    CompanyNetworkTypeLinkCreateManyWithoutNetworkTypeInput
  >;
  deviceNetworkTypeLinks?: Maybe<
    DeviceNetworkTypeLinkCreateManyWithoutNetworkTypeInput
  >;
  deviceProfiles?: Maybe<DeviceProfileCreateManyWithoutNetworkTypeInput>;
  networkProtocols?: Maybe<NetworkProtocolCreateManyWithoutNetworkTypeInput>;
  networks?: Maybe<NetworkCreateManyWithoutNetworkTypeInput>;
}

export interface NetworkUpdateManyDataInput {
  name?: Maybe<String>;
  baseUrl?: Maybe<String>;
  securityData?: Maybe<String>;
}

export interface NetworkUpdateWithoutNetworkProviderDataInput {
  name?: Maybe<String>;
  networkType?: Maybe<NetworkTypeUpdateOneRequiredWithoutNetworksInput>;
  networkProtocol?: Maybe<NetworkProtocolUpdateOneRequiredWithoutNetworksInput>;
  baseUrl?: Maybe<String>;
  securityData?: Maybe<String>;
  protocolData?: Maybe<ProtocolDataUpdateManyWithoutNetworkInput>;
}

export interface NetworkTypeUpsertWithoutNetworkProtocolsInput {
  update: NetworkTypeUpdateWithoutNetworkProtocolsDataInput;
  create: NetworkTypeCreateWithoutNetworkProtocolsInput;
}

export interface NetworkProviderUpdateInput {
  name?: Maybe<String>;
  networks?: Maybe<NetworkUpdateManyWithoutNetworkProviderInput>;
}

export interface NetworkProtocolUpsertWithoutProtocolDataInput {
  update: NetworkProtocolUpdateWithoutProtocolDataDataInput;
  create: NetworkProtocolCreateWithoutProtocolDataInput;
}

export interface NetworkProviderCreateInput {
  name?: Maybe<String>;
  networks?: Maybe<NetworkCreateManyWithoutNetworkProviderInput>;
}

export interface ProtocolDataUpsertWithWhereUniqueWithoutNetworkInput {
  where: ProtocolDataWhereUniqueInput;
  update: ProtocolDataUpdateWithoutNetworkDataInput;
  create: ProtocolDataCreateWithoutNetworkInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
  username?: Maybe<String>;
}>;

export interface NetworkUpsertWithWhereUniqueWithoutNetworkProtocolInput {
  where: NetworkWhereUniqueInput;
  update: NetworkUpdateWithoutNetworkProtocolDataInput;
  create: NetworkCreateWithoutNetworkProtocolInput;
}

export type UserRoleWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
  name?: Maybe<String>;
}>;

export interface NetworkProtocolUpsertWithWhereUniqueWithoutNetworkTypeInput {
  where: NetworkProtocolWhereUniqueInput;
  update: NetworkProtocolUpdateWithoutNetworkTypeDataInput;
  create: NetworkProtocolCreateWithoutNetworkTypeInput;
}

export interface CompanyUpdateWithoutUsersDataInput {
  name?: Maybe<String>;
  type?: Maybe<CompanyTypeUpdateOneWithoutCompaniesInput>;
  applications?: Maybe<ApplicationUpdateManyWithoutCompanyInput>;
  companyNetworkTypeLinks?: Maybe<
    CompanyNetworkTypeLinkUpdateManyWithoutCompanyInput
  >;
  deviceProfiles?: Maybe<DeviceProfileUpdateManyWithoutCompanyInput>;
  passwordPolicies?: Maybe<PasswordPolicyUpdateManyWithoutCompanyInput>;
}

export interface NetworkProtocolScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  protocolHandler?: Maybe<String>;
  protocolHandler_not?: Maybe<String>;
  protocolHandler_in?: Maybe<String[] | String>;
  protocolHandler_not_in?: Maybe<String[] | String>;
  protocolHandler_lt?: Maybe<String>;
  protocolHandler_lte?: Maybe<String>;
  protocolHandler_gt?: Maybe<String>;
  protocolHandler_gte?: Maybe<String>;
  protocolHandler_contains?: Maybe<String>;
  protocolHandler_not_contains?: Maybe<String>;
  protocolHandler_starts_with?: Maybe<String>;
  protocolHandler_not_starts_with?: Maybe<String>;
  protocolHandler_ends_with?: Maybe<String>;
  protocolHandler_not_ends_with?: Maybe<String>;
  networkProtocolVersion?: Maybe<String>;
  networkProtocolVersion_not?: Maybe<String>;
  networkProtocolVersion_in?: Maybe<String[] | String>;
  networkProtocolVersion_not_in?: Maybe<String[] | String>;
  networkProtocolVersion_lt?: Maybe<String>;
  networkProtocolVersion_lte?: Maybe<String>;
  networkProtocolVersion_gt?: Maybe<String>;
  networkProtocolVersion_gte?: Maybe<String>;
  networkProtocolVersion_contains?: Maybe<String>;
  networkProtocolVersion_not_contains?: Maybe<String>;
  networkProtocolVersion_starts_with?: Maybe<String>;
  networkProtocolVersion_not_starts_with?: Maybe<String>;
  networkProtocolVersion_ends_with?: Maybe<String>;
  networkProtocolVersion_not_ends_with?: Maybe<String>;
  masterProtocol?: Maybe<Int>;
  masterProtocol_not?: Maybe<Int>;
  masterProtocol_in?: Maybe<Int[] | Int>;
  masterProtocol_not_in?: Maybe<Int[] | Int>;
  masterProtocol_lt?: Maybe<Int>;
  masterProtocol_lte?: Maybe<Int>;
  masterProtocol_gt?: Maybe<Int>;
  masterProtocol_gte?: Maybe<Int>;
  AND?: Maybe<
    NetworkProtocolScalarWhereInput[] | NetworkProtocolScalarWhereInput
  >;
  OR?: Maybe<
    NetworkProtocolScalarWhereInput[] | NetworkProtocolScalarWhereInput
  >;
  NOT?: Maybe<
    NetworkProtocolScalarWhereInput[] | NetworkProtocolScalarWhereInput
  >;
}

export interface CompanyCreateOneWithoutApplicationsInput {
  create?: Maybe<CompanyCreateWithoutApplicationsInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface NetworkProtocolUpdateManyWithWhereNestedInput {
  where: NetworkProtocolScalarWhereInput;
  data: NetworkProtocolUpdateManyDataInput;
}

export interface CompanyNetworkTypeLinkCreateManyWithoutCompanyInput {
  create?: Maybe<
    | CompanyNetworkTypeLinkCreateWithoutCompanyInput[]
    | CompanyNetworkTypeLinkCreateWithoutCompanyInput
  >;
  connect?: Maybe<
    | CompanyNetworkTypeLinkWhereUniqueInput[]
    | CompanyNetworkTypeLinkWhereUniqueInput
  >;
}

export interface NetworkProtocolUpdateManyDataInput {
  name?: Maybe<String>;
  protocolHandler?: Maybe<String>;
  networkProtocolVersion?: Maybe<String>;
  masterProtocol?: Maybe<Int>;
}

export interface ApplicationNetworkTypeLinkCreateManyWithoutNetworkTypeInput {
  create?: Maybe<
    | ApplicationNetworkTypeLinkCreateWithoutNetworkTypeInput[]
    | ApplicationNetworkTypeLinkCreateWithoutNetworkTypeInput
  >;
  connect?: Maybe<
    | ApplicationNetworkTypeLinkWhereUniqueInput[]
    | ApplicationNetworkTypeLinkWhereUniqueInput
  >;
}

export interface NetworkTypeUpsertWithoutDeviceProfilesInput {
  update: NetworkTypeUpdateWithoutDeviceProfilesDataInput;
  create: NetworkTypeCreateWithoutDeviceProfilesInput;
}

export interface ReportingProtocolCreateOneWithoutApplicationsInput {
  create?: Maybe<ReportingProtocolCreateWithoutApplicationsInput>;
  connect?: Maybe<ReportingProtocolWhereUniqueInput>;
}

export interface DeviceProfileUpsertWithoutDeviceNetworkTypeLinksInput {
  update: DeviceProfileUpdateWithoutDeviceNetworkTypeLinksDataInput;
  create: DeviceProfileCreateWithoutDeviceNetworkTypeLinksInput;
}

export interface DeviceNetworkTypeLinkCreateManyWithoutDeviceInput {
  create?: Maybe<
    | DeviceNetworkTypeLinkCreateWithoutDeviceInput[]
    | DeviceNetworkTypeLinkCreateWithoutDeviceInput
  >;
  connect?: Maybe<
    | DeviceNetworkTypeLinkWhereUniqueInput[]
    | DeviceNetworkTypeLinkWhereUniqueInput
  >;
}

export interface DeviceNetworkTypeLinkUpsertWithWhereUniqueWithoutNetworkTypeInput {
  where: DeviceNetworkTypeLinkWhereUniqueInput;
  update: DeviceNetworkTypeLinkUpdateWithoutNetworkTypeDataInput;
  create: DeviceNetworkTypeLinkCreateWithoutNetworkTypeInput;
}

export interface CompanyNetworkTypeLinkCreateManyWithoutNetworkTypeInput {
  create?: Maybe<
    | CompanyNetworkTypeLinkCreateWithoutNetworkTypeInput[]
    | CompanyNetworkTypeLinkCreateWithoutNetworkTypeInput
  >;
  connect?: Maybe<
    | CompanyNetworkTypeLinkWhereUniqueInput[]
    | CompanyNetworkTypeLinkWhereUniqueInput
  >;
}

export interface NetworkTypeUpsertWithoutApplicationNetworkTypeLinksInput {
  update: NetworkTypeUpdateWithoutApplicationNetworkTypeLinksDataInput;
  create: NetworkTypeCreateWithoutApplicationNetworkTypeLinksInput;
}

export interface ApplicationCreateManyWithoutCompanyInput {
  create?: Maybe<
    | ApplicationCreateWithoutCompanyInput[]
    | ApplicationCreateWithoutCompanyInput
  >;
  connect?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
}

export interface ApplicationNetworkTypeLinkUpsertWithWhereUniqueWithoutApplicationInput {
  where: ApplicationNetworkTypeLinkWhereUniqueInput;
  update: ApplicationNetworkTypeLinkUpdateWithoutApplicationDataInput;
  create: ApplicationNetworkTypeLinkCreateWithoutApplicationInput;
}

export interface NetworkTypeCreateOneWithoutApplicationNetworkTypeLinksInput {
  create?: Maybe<NetworkTypeCreateWithoutApplicationNetworkTypeLinksInput>;
  connect?: Maybe<NetworkTypeWhereUniqueInput>;
}

export interface ApplicationNetworkTypeLinkScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  networkSettings?: Maybe<String>;
  networkSettings_not?: Maybe<String>;
  networkSettings_in?: Maybe<String[] | String>;
  networkSettings_not_in?: Maybe<String[] | String>;
  networkSettings_lt?: Maybe<String>;
  networkSettings_lte?: Maybe<String>;
  networkSettings_gt?: Maybe<String>;
  networkSettings_gte?: Maybe<String>;
  networkSettings_contains?: Maybe<String>;
  networkSettings_not_contains?: Maybe<String>;
  networkSettings_starts_with?: Maybe<String>;
  networkSettings_not_starts_with?: Maybe<String>;
  networkSettings_ends_with?: Maybe<String>;
  networkSettings_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    | ApplicationNetworkTypeLinkScalarWhereInput[]
    | ApplicationNetworkTypeLinkScalarWhereInput
  >;
  OR?: Maybe<
    | ApplicationNetworkTypeLinkScalarWhereInput[]
    | ApplicationNetworkTypeLinkScalarWhereInput
  >;
  NOT?: Maybe<
    | ApplicationNetworkTypeLinkScalarWhereInput[]
    | ApplicationNetworkTypeLinkScalarWhereInput
  >;
}

export interface DeviceCreateOneWithoutDeviceNetworkTypeLinksInput {
  create?: Maybe<DeviceCreateWithoutDeviceNetworkTypeLinksInput>;
  connect?: Maybe<DeviceWhereUniqueInput>;
}

export interface ApplicationNetworkTypeLinkUpdateManyWithWhereNestedInput {
  where: ApplicationNetworkTypeLinkScalarWhereInput;
  data: ApplicationNetworkTypeLinkUpdateManyDataInput;
}

export interface DeviceProfileCreateOneWithoutDeviceNetworkTypeLinksInput {
  create?: Maybe<DeviceProfileCreateWithoutDeviceNetworkTypeLinksInput>;
  connect?: Maybe<DeviceProfileWhereUniqueInput>;
}

export interface ApplicationNetworkTypeLinkUpdateManyDataInput {
  networkSettings?: Maybe<String>;
}

export interface NetworkProtocolCreateManyWithoutNetworkTypeInput {
  create?: Maybe<
    | NetworkProtocolCreateWithoutNetworkTypeInput[]
    | NetworkProtocolCreateWithoutNetworkTypeInput
  >;
  connect?: Maybe<
    NetworkProtocolWhereUniqueInput[] | NetworkProtocolWhereUniqueInput
  >;
}

export interface ApplicationUpsertWithWhereUniqueWithoutCompanyInput {
  where: ApplicationWhereUniqueInput;
  update: ApplicationUpdateWithoutCompanyDataInput;
  create: ApplicationCreateWithoutCompanyInput;
}

export interface NetworkProviderCreateOneWithoutNetworksInput {
  create?: Maybe<NetworkProviderCreateWithoutNetworksInput>;
  connect?: Maybe<NetworkProviderWhereUniqueInput>;
}

export interface ApplicationScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  baseUrl?: Maybe<String>;
  baseUrl_not?: Maybe<String>;
  baseUrl_in?: Maybe<String[] | String>;
  baseUrl_not_in?: Maybe<String[] | String>;
  baseUrl_lt?: Maybe<String>;
  baseUrl_lte?: Maybe<String>;
  baseUrl_gt?: Maybe<String>;
  baseUrl_gte?: Maybe<String>;
  baseUrl_contains?: Maybe<String>;
  baseUrl_not_contains?: Maybe<String>;
  baseUrl_starts_with?: Maybe<String>;
  baseUrl_not_starts_with?: Maybe<String>;
  baseUrl_ends_with?: Maybe<String>;
  baseUrl_not_ends_with?: Maybe<String>;
  enabled?: Maybe<Boolean>;
  enabled_not?: Maybe<Boolean>;
  AND?: Maybe<ApplicationScalarWhereInput[] | ApplicationScalarWhereInput>;
  OR?: Maybe<ApplicationScalarWhereInput[] | ApplicationScalarWhereInput>;
  NOT?: Maybe<ApplicationScalarWhereInput[] | ApplicationScalarWhereInput>;
}

export interface DeviceProfileCreateManyWithoutNetworkTypeInput {
  create?: Maybe<
    | DeviceProfileCreateWithoutNetworkTypeInput[]
    | DeviceProfileCreateWithoutNetworkTypeInput
  >;
  connect?: Maybe<
    DeviceProfileWhereUniqueInput[] | DeviceProfileWhereUniqueInput
  >;
}

export interface ApplicationUpdateManyWithWhereNestedInput {
  where: ApplicationScalarWhereInput;
  data: ApplicationUpdateManyDataInput;
}

export interface PasswordPolicyCreateManyWithoutCompanyInput {
  create?: Maybe<
    | PasswordPolicyCreateWithoutCompanyInput[]
    | PasswordPolicyCreateWithoutCompanyInput
  >;
  connect?: Maybe<
    PasswordPolicyWhereUniqueInput[] | PasswordPolicyWhereUniqueInput
  >;
}

export interface ApplicationUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  baseUrl?: Maybe<String>;
  enabled?: Maybe<Boolean>;
}

export interface UserRoleCreateOneWithoutUsersInput {
  create?: Maybe<UserRoleCreateWithoutUsersInput>;
  connect?: Maybe<UserRoleWhereUniqueInput>;
}

export interface DeviceProfileUpdateManyWithoutCompanyInput {
  create?: Maybe<
    | DeviceProfileCreateWithoutCompanyInput[]
    | DeviceProfileCreateWithoutCompanyInput
  >;
  delete?: Maybe<
    DeviceProfileWhereUniqueInput[] | DeviceProfileWhereUniqueInput
  >;
  connect?: Maybe<
    DeviceProfileWhereUniqueInput[] | DeviceProfileWhereUniqueInput
  >;
  set?: Maybe<DeviceProfileWhereUniqueInput[] | DeviceProfileWhereUniqueInput>;
  disconnect?: Maybe<
    DeviceProfileWhereUniqueInput[] | DeviceProfileWhereUniqueInput
  >;
  update?: Maybe<
    | DeviceProfileUpdateWithWhereUniqueWithoutCompanyInput[]
    | DeviceProfileUpdateWithWhereUniqueWithoutCompanyInput
  >;
  upsert?: Maybe<
    | DeviceProfileUpsertWithWhereUniqueWithoutCompanyInput[]
    | DeviceProfileUpsertWithWhereUniqueWithoutCompanyInput
  >;
  deleteMany?: Maybe<
    DeviceProfileScalarWhereInput[] | DeviceProfileScalarWhereInput
  >;
  updateMany?: Maybe<
    | DeviceProfileUpdateManyWithWhereNestedInput[]
    | DeviceProfileUpdateManyWithWhereNestedInput
  >;
}

export interface DeviceNetworkTypeLinkCreateManyWithoutDeviceProfileInput {
  create?: Maybe<
    | DeviceNetworkTypeLinkCreateWithoutDeviceProfileInput[]
    | DeviceNetworkTypeLinkCreateWithoutDeviceProfileInput
  >;
  connect?: Maybe<
    | DeviceNetworkTypeLinkWhereUniqueInput[]
    | DeviceNetworkTypeLinkWhereUniqueInput
  >;
}

export interface DeviceProfileUpdateWithWhereUniqueWithoutCompanyInput {
  where: DeviceProfileWhereUniqueInput;
  data: DeviceProfileUpdateWithoutCompanyDataInput;
}

export interface NetworkProtocolCreateOneWithoutProtocolDataInput {
  create?: Maybe<NetworkProtocolCreateWithoutProtocolDataInput>;
  connect?: Maybe<NetworkProtocolWhereUniqueInput>;
}

export interface DeviceProfileUpdateWithoutCompanyDataInput {
  networkType?: Maybe<NetworkTypeUpdateOneRequiredWithoutDeviceProfilesInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  networkSettings?: Maybe<String>;
  deviceNetworkTypeLinks?: Maybe<
    DeviceNetworkTypeLinkUpdateManyWithoutDeviceProfileInput
  >;
}

export interface NetworkCreateManyWithoutNetworkTypeInput {
  create?: Maybe<
    | NetworkCreateWithoutNetworkTypeInput[]
    | NetworkCreateWithoutNetworkTypeInput
  >;
  connect?: Maybe<NetworkWhereUniqueInput[] | NetworkWhereUniqueInput>;
}

export interface DeviceProfileUpsertWithWhereUniqueWithoutCompanyInput {
  where: DeviceProfileWhereUniqueInput;
  update: DeviceProfileUpdateWithoutCompanyDataInput;
  create: DeviceProfileCreateWithoutCompanyInput;
}

export interface ProtocolDataCreateManyWithoutNetworkProtocolInput {
  create?: Maybe<
    | ProtocolDataCreateWithoutNetworkProtocolInput[]
    | ProtocolDataCreateWithoutNetworkProtocolInput
  >;
  connect?: Maybe<
    ProtocolDataWhereUniqueInput[] | ProtocolDataWhereUniqueInput
  >;
}

export interface CompanyUpsertWithoutCompanyNetworkTypeLinksInput {
  update: CompanyUpdateWithoutCompanyNetworkTypeLinksDataInput;
  create: CompanyCreateWithoutCompanyNetworkTypeLinksInput;
}

export interface DeviceProfileCreateManyWithoutCompanyInput {
  create?: Maybe<
    | DeviceProfileCreateWithoutCompanyInput[]
    | DeviceProfileCreateWithoutCompanyInput
  >;
  connect?: Maybe<
    DeviceProfileWhereUniqueInput[] | DeviceProfileWhereUniqueInput
  >;
}

export interface CompanyNetworkTypeLinkUpsertWithWhereUniqueWithoutNetworkTypeInput {
  where: CompanyNetworkTypeLinkWhereUniqueInput;
  update: CompanyNetworkTypeLinkUpdateWithoutNetworkTypeDataInput;
  create: CompanyNetworkTypeLinkCreateWithoutNetworkTypeInput;
}

export interface CompanyUpdateWithoutApplicationsDataInput {
  name?: Maybe<String>;
  type?: Maybe<CompanyTypeUpdateOneWithoutCompaniesInput>;
  companyNetworkTypeLinks?: Maybe<
    CompanyNetworkTypeLinkUpdateManyWithoutCompanyInput
  >;
  deviceProfiles?: Maybe<DeviceProfileUpdateManyWithoutCompanyInput>;
  passwordPolicies?: Maybe<PasswordPolicyUpdateManyWithoutCompanyInput>;
  users?: Maybe<UserUpdateManyWithoutCompanyInput>;
}

export interface CompanyNetworkTypeLinkScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  networkSettings?: Maybe<String>;
  networkSettings_not?: Maybe<String>;
  networkSettings_in?: Maybe<String[] | String>;
  networkSettings_not_in?: Maybe<String[] | String>;
  networkSettings_lt?: Maybe<String>;
  networkSettings_lte?: Maybe<String>;
  networkSettings_gt?: Maybe<String>;
  networkSettings_gte?: Maybe<String>;
  networkSettings_contains?: Maybe<String>;
  networkSettings_not_contains?: Maybe<String>;
  networkSettings_starts_with?: Maybe<String>;
  networkSettings_not_starts_with?: Maybe<String>;
  networkSettings_ends_with?: Maybe<String>;
  networkSettings_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    | CompanyNetworkTypeLinkScalarWhereInput[]
    | CompanyNetworkTypeLinkScalarWhereInput
  >;
  OR?: Maybe<
    | CompanyNetworkTypeLinkScalarWhereInput[]
    | CompanyNetworkTypeLinkScalarWhereInput
  >;
  NOT?: Maybe<
    | CompanyNetworkTypeLinkScalarWhereInput[]
    | CompanyNetworkTypeLinkScalarWhereInput
  >;
}

export interface CompanyNetworkTypeLinkUpdateManyWithoutCompanyInput {
  create?: Maybe<
    | CompanyNetworkTypeLinkCreateWithoutCompanyInput[]
    | CompanyNetworkTypeLinkCreateWithoutCompanyInput
  >;
  delete?: Maybe<
    | CompanyNetworkTypeLinkWhereUniqueInput[]
    | CompanyNetworkTypeLinkWhereUniqueInput
  >;
  connect?: Maybe<
    | CompanyNetworkTypeLinkWhereUniqueInput[]
    | CompanyNetworkTypeLinkWhereUniqueInput
  >;
  set?: Maybe<
    | CompanyNetworkTypeLinkWhereUniqueInput[]
    | CompanyNetworkTypeLinkWhereUniqueInput
  >;
  disconnect?: Maybe<
    | CompanyNetworkTypeLinkWhereUniqueInput[]
    | CompanyNetworkTypeLinkWhereUniqueInput
  >;
  update?: Maybe<
    | CompanyNetworkTypeLinkUpdateWithWhereUniqueWithoutCompanyInput[]
    | CompanyNetworkTypeLinkUpdateWithWhereUniqueWithoutCompanyInput
  >;
  upsert?: Maybe<
    | CompanyNetworkTypeLinkUpsertWithWhereUniqueWithoutCompanyInput[]
    | CompanyNetworkTypeLinkUpsertWithWhereUniqueWithoutCompanyInput
  >;
  deleteMany?: Maybe<
    | CompanyNetworkTypeLinkScalarWhereInput[]
    | CompanyNetworkTypeLinkScalarWhereInput
  >;
  updateMany?: Maybe<
    | CompanyNetworkTypeLinkUpdateManyWithWhereNestedInput[]
    | CompanyNetworkTypeLinkUpdateManyWithWhereNestedInput
  >;
}

export interface CompanyNetworkTypeLinkUpdateManyWithWhereNestedInput {
  where: CompanyNetworkTypeLinkScalarWhereInput;
  data: CompanyNetworkTypeLinkUpdateManyDataInput;
}

export interface NetworkTypeUpdateWithoutCompanyNetworkTypeLinksDataInput {
  name?: Maybe<String>;
  applicationNetworkTypeLinks?: Maybe<
    ApplicationNetworkTypeLinkUpdateManyWithoutNetworkTypeInput
  >;
  deviceNetworkTypeLinks?: Maybe<
    DeviceNetworkTypeLinkUpdateManyWithoutNetworkTypeInput
  >;
  deviceProfiles?: Maybe<DeviceProfileUpdateManyWithoutNetworkTypeInput>;
  networkProtocols?: Maybe<NetworkProtocolUpdateManyWithoutNetworkTypeInput>;
  networks?: Maybe<NetworkUpdateManyWithoutNetworkTypeInput>;
}

export interface CompanyNetworkTypeLinkUpdateManyDataInput {
  networkSettings?: Maybe<String>;
}

export interface UserRoleSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserRoleWhereInput>;
  AND?: Maybe<
    UserRoleSubscriptionWhereInput[] | UserRoleSubscriptionWhereInput
  >;
  OR?: Maybe<UserRoleSubscriptionWhereInput[] | UserRoleSubscriptionWhereInput>;
  NOT?: Maybe<
    UserRoleSubscriptionWhereInput[] | UserRoleSubscriptionWhereInput
  >;
}

export interface NetworkTypeUpsertWithoutDeviceNetworkTypeLinksInput {
  update: NetworkTypeUpdateWithoutDeviceNetworkTypeLinksDataInput;
  create: NetworkTypeCreateWithoutDeviceNetworkTypeLinksInput;
}

export interface CompanyNetworkTypeLinkWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  company?: Maybe<CompanyWhereInput>;
  networkType?: Maybe<NetworkTypeWhereInput>;
  networkSettings?: Maybe<String>;
  networkSettings_not?: Maybe<String>;
  networkSettings_in?: Maybe<String[] | String>;
  networkSettings_not_in?: Maybe<String[] | String>;
  networkSettings_lt?: Maybe<String>;
  networkSettings_lte?: Maybe<String>;
  networkSettings_gt?: Maybe<String>;
  networkSettings_gte?: Maybe<String>;
  networkSettings_contains?: Maybe<String>;
  networkSettings_not_contains?: Maybe<String>;
  networkSettings_starts_with?: Maybe<String>;
  networkSettings_not_starts_with?: Maybe<String>;
  networkSettings_ends_with?: Maybe<String>;
  networkSettings_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    CompanyNetworkTypeLinkWhereInput[] | CompanyNetworkTypeLinkWhereInput
  >;
  OR?: Maybe<
    CompanyNetworkTypeLinkWhereInput[] | CompanyNetworkTypeLinkWhereInput
  >;
  NOT?: Maybe<
    CompanyNetworkTypeLinkWhereInput[] | CompanyNetworkTypeLinkWhereInput
  >;
}

export interface DeviceNetworkTypeLinkUpsertWithWhereUniqueWithoutDeviceInput {
  where: DeviceNetworkTypeLinkWhereUniqueInput;
  update: DeviceNetworkTypeLinkUpdateWithoutDeviceDataInput;
  create: DeviceNetworkTypeLinkCreateWithoutDeviceInput;
}

export interface EmailVerificationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EmailVerificationWhereInput>;
  AND?: Maybe<
    | EmailVerificationSubscriptionWhereInput[]
    | EmailVerificationSubscriptionWhereInput
  >;
  OR?: Maybe<
    | EmailVerificationSubscriptionWhereInput[]
    | EmailVerificationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | EmailVerificationSubscriptionWhereInput[]
    | EmailVerificationSubscriptionWhereInput
  >;
}

export interface DeviceUpsertWithWhereUniqueWithoutApplicationInput {
  where: DeviceWhereUniqueInput;
  update: DeviceUpdateWithoutApplicationDataInput;
  create: DeviceCreateWithoutApplicationInput;
}

export interface ApplicationNetworkTypeLinkSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ApplicationNetworkTypeLinkWhereInput>;
  AND?: Maybe<
    | ApplicationNetworkTypeLinkSubscriptionWhereInput[]
    | ApplicationNetworkTypeLinkSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ApplicationNetworkTypeLinkSubscriptionWhereInput[]
    | ApplicationNetworkTypeLinkSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ApplicationNetworkTypeLinkSubscriptionWhereInput[]
    | ApplicationNetworkTypeLinkSubscriptionWhereInput
  >;
}

export interface DeviceScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  deviceModel?: Maybe<String>;
  deviceModel_not?: Maybe<String>;
  deviceModel_in?: Maybe<String[] | String>;
  deviceModel_not_in?: Maybe<String[] | String>;
  deviceModel_lt?: Maybe<String>;
  deviceModel_lte?: Maybe<String>;
  deviceModel_gt?: Maybe<String>;
  deviceModel_gte?: Maybe<String>;
  deviceModel_contains?: Maybe<String>;
  deviceModel_not_contains?: Maybe<String>;
  deviceModel_starts_with?: Maybe<String>;
  deviceModel_not_starts_with?: Maybe<String>;
  deviceModel_ends_with?: Maybe<String>;
  deviceModel_not_ends_with?: Maybe<String>;
  AND?: Maybe<DeviceScalarWhereInput[] | DeviceScalarWhereInput>;
  OR?: Maybe<DeviceScalarWhereInput[] | DeviceScalarWhereInput>;
  NOT?: Maybe<DeviceScalarWhereInput[] | DeviceScalarWhereInput>;
}

export interface UserUpdateManyWithoutRoleInput {
  create?: Maybe<UserCreateWithoutRoleInput[] | UserCreateWithoutRoleInput>;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutRoleInput[]
    | UserUpdateWithWhereUniqueWithoutRoleInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutRoleInput[]
    | UserUpsertWithWhereUniqueWithoutRoleInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface DeviceUpdateManyWithWhereNestedInput {
  where: DeviceScalarWhereInput;
  data: DeviceUpdateManyDataInput;
}

export interface UserUpdateManyMutationInput {
  username?: Maybe<String>;
  email?: Maybe<String>;
  lastVerifiedEmail?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  passwordHash?: Maybe<String>;
}

export interface DeviceUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  deviceModel?: Maybe<String>;
}

export interface ApplicationUpdateWithWhereUniqueWithoutReportingProtocolInput {
  where: ApplicationWhereUniqueInput;
  data: ApplicationUpdateWithoutReportingProtocolDataInput;
}

export interface ApplicationUpsertWithoutApplicationNetworkTypeLinksInput {
  update: ApplicationUpdateWithoutApplicationNetworkTypeLinksDataInput;
  create: ApplicationCreateWithoutApplicationNetworkTypeLinksInput;
}

export interface ProtocolDataUpdateManyMutationInput {
  dataIdentifier?: Maybe<String>;
  dataValue?: Maybe<String>;
}

export interface ApplicationNetworkTypeLinkUpsertWithWhereUniqueWithoutNetworkTypeInput {
  where: ApplicationNetworkTypeLinkWhereUniqueInput;
  update: ApplicationNetworkTypeLinkUpdateWithoutNetworkTypeDataInput;
  create: ApplicationNetworkTypeLinkCreateWithoutNetworkTypeInput;
}

export interface CompanyUpdateOneWithoutPasswordPoliciesInput {
  create?: Maybe<CompanyCreateWithoutPasswordPoliciesInput>;
  update?: Maybe<CompanyUpdateWithoutPasswordPoliciesDataInput>;
  upsert?: Maybe<CompanyUpsertWithoutPasswordPoliciesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface NetworkTypeUpsertWithoutCompanyNetworkTypeLinksInput {
  update: NetworkTypeUpdateWithoutCompanyNetworkTypeLinksDataInput;
  create: NetworkTypeCreateWithoutCompanyNetworkTypeLinksInput;
}

export type NetworkTypeWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
  name?: Maybe<String>;
}>;

export interface CompanyNetworkTypeLinkUpsertWithWhereUniqueWithoutCompanyInput {
  where: CompanyNetworkTypeLinkWhereUniqueInput;
  update: CompanyNetworkTypeLinkUpdateWithoutCompanyDataInput;
  create: CompanyNetworkTypeLinkCreateWithoutCompanyInput;
}

export interface NetworkUpdateManyWithoutNetworkProviderInput {
  create?: Maybe<
    | NetworkCreateWithoutNetworkProviderInput[]
    | NetworkCreateWithoutNetworkProviderInput
  >;
  delete?: Maybe<NetworkWhereUniqueInput[] | NetworkWhereUniqueInput>;
  connect?: Maybe<NetworkWhereUniqueInput[] | NetworkWhereUniqueInput>;
  set?: Maybe<NetworkWhereUniqueInput[] | NetworkWhereUniqueInput>;
  disconnect?: Maybe<NetworkWhereUniqueInput[] | NetworkWhereUniqueInput>;
  update?: Maybe<
    | NetworkUpdateWithWhereUniqueWithoutNetworkProviderInput[]
    | NetworkUpdateWithWhereUniqueWithoutNetworkProviderInput
  >;
  upsert?: Maybe<
    | NetworkUpsertWithWhereUniqueWithoutNetworkProviderInput[]
    | NetworkUpsertWithWhereUniqueWithoutNetworkProviderInput
  >;
  deleteMany?: Maybe<NetworkScalarWhereInput[] | NetworkScalarWhereInput>;
  updateMany?: Maybe<
    | NetworkUpdateManyWithWhereNestedInput[]
    | NetworkUpdateManyWithWhereNestedInput
  >;
}

export interface CompanyUpsertWithoutApplicationsInput {
  update: CompanyUpdateWithoutApplicationsDataInput;
  create: CompanyCreateWithoutApplicationsInput;
}

export interface NetworkProtocolUpdateInput {
  name?: Maybe<String>;
  protocolHandler?: Maybe<String>;
  networkType?: Maybe<NetworkTypeUpdateOneRequiredWithoutNetworkProtocolsInput>;
  networkProtocolVersion?: Maybe<String>;
  masterProtocol?: Maybe<Int>;
  networks?: Maybe<NetworkUpdateManyWithoutNetworkProtocolInput>;
  protocolData?: Maybe<ProtocolDataUpdateManyWithoutNetworkProtocolInput>;
}

export interface ApplicationUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  baseUrl?: Maybe<String>;
  enabled?: Maybe<Boolean>;
}

export interface UserUpsertWithoutEmailVerificationsInput {
  update: UserUpdateWithoutEmailVerificationsDataInput;
  create: UserCreateWithoutEmailVerificationsInput;
}

export interface EmailVerificationUpdateInput {
  user?: Maybe<UserUpdateOneRequiredWithoutEmailVerificationsInput>;
  uuid?: Maybe<String>;
  email?: Maybe<String>;
  changeRequested?: Maybe<String>;
}

export interface CompanyTypeCreateOneWithoutCompaniesInput {
  create?: Maybe<CompanyTypeCreateWithoutCompaniesInput>;
  connect?: Maybe<CompanyTypeWhereUniqueInput>;
}

export interface CompanyCreateWithoutUsersInput {
  name?: Maybe<String>;
  type?: Maybe<CompanyTypeCreateOneWithoutCompaniesInput>;
  applications?: Maybe<ApplicationCreateManyWithoutCompanyInput>;
  companyNetworkTypeLinks?: Maybe<
    CompanyNetworkTypeLinkCreateManyWithoutCompanyInput
  >;
  deviceProfiles?: Maybe<DeviceProfileCreateManyWithoutCompanyInput>;
  passwordPolicies?: Maybe<PasswordPolicyCreateManyWithoutCompanyInput>;
}

export interface ApplicationCreateOneWithoutApplicationNetworkTypeLinksInput {
  create?: Maybe<ApplicationCreateWithoutApplicationNetworkTypeLinksInput>;
  connect?: Maybe<ApplicationWhereUniqueInput>;
}

export interface ApplicationNetworkTypeLinkCreateInput {
  application: ApplicationCreateOneWithoutApplicationNetworkTypeLinksInput;
  networkType: NetworkTypeCreateOneWithoutApplicationNetworkTypeLinksInput;
  networkSettings?: Maybe<String>;
}

export interface NetworkTypeCreateOneWithoutDeviceNetworkTypeLinksInput {
  create?: Maybe<NetworkTypeCreateWithoutDeviceNetworkTypeLinksInput>;
  connect?: Maybe<NetworkTypeWhereUniqueInput>;
}

export interface ApplicationNetworkTypeLinkUpdateInput {
  application?: Maybe<
    ApplicationUpdateOneRequiredWithoutApplicationNetworkTypeLinksInput
  >;
  networkType?: Maybe<
    NetworkTypeUpdateOneRequiredWithoutApplicationNetworkTypeLinksInput
  >;
  networkSettings?: Maybe<String>;
}

export interface ApplicationNetworkTypeLinkCreateManyWithoutApplicationInput {
  create?: Maybe<
    | ApplicationNetworkTypeLinkCreateWithoutApplicationInput[]
    | ApplicationNetworkTypeLinkCreateWithoutApplicationInput
  >;
  connect?: Maybe<
    | ApplicationNetworkTypeLinkWhereUniqueInput[]
    | ApplicationNetworkTypeLinkWhereUniqueInput
  >;
}

export interface ApplicationNetworkTypeLinkUpdateManyMutationInput {
  networkSettings?: Maybe<String>;
}

export interface ApplicationCreateOneWithoutDevicesInput {
  create?: Maybe<ApplicationCreateWithoutDevicesInput>;
  connect?: Maybe<ApplicationWhereUniqueInput>;
}

export interface CompanyCreateInput {
  name?: Maybe<String>;
  type?: Maybe<CompanyTypeCreateOneWithoutCompaniesInput>;
  applications?: Maybe<ApplicationCreateManyWithoutCompanyInput>;
  companyNetworkTypeLinks?: Maybe<
    CompanyNetworkTypeLinkCreateManyWithoutCompanyInput
  >;
  deviceProfiles?: Maybe<DeviceProfileCreateManyWithoutCompanyInput>;
  passwordPolicies?: Maybe<PasswordPolicyCreateManyWithoutCompanyInput>;
  users?: Maybe<UserCreateManyWithoutCompanyInput>;
}

export interface NetworkCreateManyWithoutNetworkProtocolInput {
  create?: Maybe<
    | NetworkCreateWithoutNetworkProtocolInput[]
    | NetworkCreateWithoutNetworkProtocolInput
  >;
  connect?: Maybe<NetworkWhereUniqueInput[] | NetworkWhereUniqueInput>;
}

export interface CompanyUpdateInput {
  name?: Maybe<String>;
  type?: Maybe<CompanyTypeUpdateOneWithoutCompaniesInput>;
  applications?: Maybe<ApplicationUpdateManyWithoutCompanyInput>;
  companyNetworkTypeLinks?: Maybe<
    CompanyNetworkTypeLinkUpdateManyWithoutCompanyInput
  >;
  deviceProfiles?: Maybe<DeviceProfileUpdateManyWithoutCompanyInput>;
  passwordPolicies?: Maybe<PasswordPolicyUpdateManyWithoutCompanyInput>;
  users?: Maybe<UserUpdateManyWithoutCompanyInput>;
}

export interface CompanyCreateOneWithoutDeviceProfilesInput {
  create?: Maybe<CompanyCreateWithoutDeviceProfilesInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface CompanyUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface EmailVerificationCreateManyWithoutUserInput {
  create?: Maybe<
    | EmailVerificationCreateWithoutUserInput[]
    | EmailVerificationCreateWithoutUserInput
  >;
  connect?: Maybe<
    EmailVerificationWhereUniqueInput[] | EmailVerificationWhereUniqueInput
  >;
}

export interface CompanyNetworkTypeLinkCreateInput {
  company: CompanyCreateOneWithoutCompanyNetworkTypeLinksInput;
  networkType: NetworkTypeCreateOneWithoutCompanyNetworkTypeLinksInput;
  networkSettings?: Maybe<String>;
}

export interface NetworkTypeCreateOneWithoutNetworkProtocolsInput {
  create?: Maybe<NetworkTypeCreateWithoutNetworkProtocolsInput>;
  connect?: Maybe<NetworkTypeWhereUniqueInput>;
}

export interface CompanyNetworkTypeLinkUpdateInput {
  company?: Maybe<CompanyUpdateOneRequiredWithoutCompanyNetworkTypeLinksInput>;
  networkType?: Maybe<
    NetworkTypeUpdateOneRequiredWithoutCompanyNetworkTypeLinksInput
  >;
  networkSettings?: Maybe<String>;
}

export interface NetworkCreateOneWithoutProtocolDataInput {
  create?: Maybe<NetworkCreateWithoutProtocolDataInput>;
  connect?: Maybe<NetworkWhereUniqueInput>;
}

export interface CompanyNetworkTypeLinkUpdateManyMutationInput {
  networkSettings?: Maybe<String>;
}

export interface CompanyTypeUpdateWithoutCompaniesDataInput {
  name?: Maybe<String>;
}

export interface CompanyTypeCreateInput {
  name?: Maybe<String>;
  companies?: Maybe<CompanyCreateManyWithoutTypeInput>;
}

export interface ApplicationNetworkTypeLinkUpdateWithWhereUniqueWithoutNetworkTypeInput {
  where: ApplicationNetworkTypeLinkWhereUniqueInput;
  data: ApplicationNetworkTypeLinkUpdateWithoutNetworkTypeDataInput;
}

export interface CompanyCreateManyWithoutTypeInput {
  create?: Maybe<
    CompanyCreateWithoutTypeInput[] | CompanyCreateWithoutTypeInput
  >;
  connect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
}

export interface NetworkProtocolSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<NetworkProtocolWhereInput>;
  AND?: Maybe<
    | NetworkProtocolSubscriptionWhereInput[]
    | NetworkProtocolSubscriptionWhereInput
  >;
  OR?: Maybe<
    | NetworkProtocolSubscriptionWhereInput[]
    | NetworkProtocolSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | NetworkProtocolSubscriptionWhereInput[]
    | NetworkProtocolSubscriptionWhereInput
  >;
}

export interface CompanyCreateWithoutTypeInput {
  name?: Maybe<String>;
  applications?: Maybe<ApplicationCreateManyWithoutCompanyInput>;
  companyNetworkTypeLinks?: Maybe<
    CompanyNetworkTypeLinkCreateManyWithoutCompanyInput
  >;
  deviceProfiles?: Maybe<DeviceProfileCreateManyWithoutCompanyInput>;
  passwordPolicies?: Maybe<PasswordPolicyCreateManyWithoutCompanyInput>;
  users?: Maybe<UserCreateManyWithoutCompanyInput>;
}

export interface UserUpsertWithWhereUniqueWithoutRoleInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutRoleDataInput;
  create: UserCreateWithoutRoleInput;
}

export interface CompanyTypeUpdateInput {
  name?: Maybe<String>;
  companies?: Maybe<CompanyUpdateManyWithoutTypeInput>;
}

export interface ReportingProtocolUpdateManyMutationInput {
  name?: Maybe<String>;
  protocolHandler?: Maybe<String>;
}

export interface CompanyUpdateManyWithoutTypeInput {
  create?: Maybe<
    CompanyCreateWithoutTypeInput[] | CompanyCreateWithoutTypeInput
  >;
  delete?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  connect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  set?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  disconnect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  update?: Maybe<
    | CompanyUpdateWithWhereUniqueWithoutTypeInput[]
    | CompanyUpdateWithWhereUniqueWithoutTypeInput
  >;
  upsert?: Maybe<
    | CompanyUpsertWithWhereUniqueWithoutTypeInput[]
    | CompanyUpsertWithWhereUniqueWithoutTypeInput
  >;
  deleteMany?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
  updateMany?: Maybe<
    | CompanyUpdateManyWithWhereNestedInput[]
    | CompanyUpdateManyWithWhereNestedInput
  >;
}

export interface PasswordPolicyUpdateManyMutationInput {
  ruleText?: Maybe<String>;
  ruleRegExp?: Maybe<String>;
}

export interface CompanyUpdateWithWhereUniqueWithoutTypeInput {
  where: CompanyWhereUniqueInput;
  data: CompanyUpdateWithoutTypeDataInput;
}

export interface NetworkUpsertWithWhereUniqueWithoutNetworkProviderInput {
  where: NetworkWhereUniqueInput;
  update: NetworkUpdateWithoutNetworkProviderDataInput;
  create: NetworkCreateWithoutNetworkProviderInput;
}

export interface CompanyUpdateWithoutTypeDataInput {
  name?: Maybe<String>;
  applications?: Maybe<ApplicationUpdateManyWithoutCompanyInput>;
  companyNetworkTypeLinks?: Maybe<
    CompanyNetworkTypeLinkUpdateManyWithoutCompanyInput
  >;
  deviceProfiles?: Maybe<DeviceProfileUpdateManyWithoutCompanyInput>;
  passwordPolicies?: Maybe<PasswordPolicyUpdateManyWithoutCompanyInput>;
  users?: Maybe<UserUpdateManyWithoutCompanyInput>;
}

export interface NetworkUpdateInput {
  name?: Maybe<String>;
  networkProvider?: Maybe<NetworkProviderUpdateOneWithoutNetworksInput>;
  networkType?: Maybe<NetworkTypeUpdateOneRequiredWithoutNetworksInput>;
  networkProtocol?: Maybe<NetworkProtocolUpdateOneRequiredWithoutNetworksInput>;
  baseUrl?: Maybe<String>;
  securityData?: Maybe<String>;
  protocolData?: Maybe<ProtocolDataUpdateManyWithoutNetworkInput>;
}

export interface CompanyUpsertWithWhereUniqueWithoutTypeInput {
  where: CompanyWhereUniqueInput;
  update: CompanyUpdateWithoutTypeDataInput;
  create: CompanyCreateWithoutTypeInput;
}

export interface NetworkTypeCreateOneWithoutCompanyNetworkTypeLinksInput {
  create?: Maybe<NetworkTypeCreateWithoutCompanyNetworkTypeLinksInput>;
  connect?: Maybe<NetworkTypeWhereUniqueInput>;
}

export interface CompanyScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
  OR?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
  NOT?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
}

export interface CompanyCreateOneWithoutCompanyNetworkTypeLinksInput {
  create?: Maybe<CompanyCreateWithoutCompanyNetworkTypeLinksInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface CompanyUpdateManyWithWhereNestedInput {
  where: CompanyScalarWhereInput;
  data: CompanyUpdateManyDataInput;
}

export interface NetworkTypeCreateOneWithoutDeviceProfilesInput {
  create?: Maybe<NetworkTypeCreateWithoutDeviceProfilesInput>;
  connect?: Maybe<NetworkTypeWhereUniqueInput>;
}

export interface CompanyUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface UserCreateManyWithoutCompanyInput {
  create?: Maybe<
    UserCreateWithoutCompanyInput[] | UserCreateWithoutCompanyInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface CompanyTypeUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface NetworkProtocolCreateOneWithoutNetworksInput {
  create?: Maybe<NetworkProtocolCreateWithoutNetworksInput>;
  connect?: Maybe<NetworkProtocolWhereUniqueInput>;
}

export interface DeviceCreateInput {
  application: ApplicationCreateOneWithoutDevicesInput;
  name?: Maybe<String>;
  description?: Maybe<String>;
  deviceModel?: Maybe<String>;
  deviceNetworkTypeLinks?: Maybe<
    DeviceNetworkTypeLinkCreateManyWithoutDeviceInput
  >;
}

export interface CompanyNetworkTypeLinkUpdateWithoutCompanyDataInput {
  networkType?: Maybe<
    NetworkTypeUpdateOneRequiredWithoutCompanyNetworkTypeLinksInput
  >;
  networkSettings?: Maybe<String>;
}

export interface DeviceUpdateInput {
  application?: Maybe<ApplicationUpdateOneRequiredWithoutDevicesInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  deviceModel?: Maybe<String>;
  deviceNetworkTypeLinks?: Maybe<
    DeviceNetworkTypeLinkUpdateManyWithoutDeviceInput
  >;
}

export interface CompanyTypeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CompanyTypeWhereInput>;
  AND?: Maybe<
    CompanyTypeSubscriptionWhereInput[] | CompanyTypeSubscriptionWhereInput
  >;
  OR?: Maybe<
    CompanyTypeSubscriptionWhereInput[] | CompanyTypeSubscriptionWhereInput
  >;
  NOT?: Maybe<
    CompanyTypeSubscriptionWhereInput[] | CompanyTypeSubscriptionWhereInput
  >;
}

export interface DeviceUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  deviceModel?: Maybe<String>;
}

export interface ApplicationCreateWithoutReportingProtocolInput {
  company?: Maybe<CompanyCreateOneWithoutApplicationsInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  baseUrl?: Maybe<String>;
  enabled?: Maybe<Boolean>;
  applicationNetworkTypeLinks?: Maybe<
    ApplicationNetworkTypeLinkCreateManyWithoutApplicationInput
  >;
  devices?: Maybe<DeviceCreateManyWithoutApplicationInput>;
}

export interface DeviceNetworkTypeLinkCreateInput {
  device: DeviceCreateOneWithoutDeviceNetworkTypeLinksInput;
  networkType: NetworkTypeCreateOneWithoutDeviceNetworkTypeLinksInput;
  deviceProfile: DeviceProfileCreateOneWithoutDeviceNetworkTypeLinksInput;
  networkSettings?: Maybe<String>;
}

export interface NetworkCreateManyWithoutNetworkProviderInput {
  create?: Maybe<
    | NetworkCreateWithoutNetworkProviderInput[]
    | NetworkCreateWithoutNetworkProviderInput
  >;
  connect?: Maybe<NetworkWhereUniqueInput[] | NetworkWhereUniqueInput>;
}

export interface DeviceNetworkTypeLinkUpdateInput {
  device?: Maybe<DeviceUpdateOneRequiredWithoutDeviceNetworkTypeLinksInput>;
  networkType?: Maybe<
    NetworkTypeUpdateOneRequiredWithoutDeviceNetworkTypeLinksInput
  >;
  deviceProfile?: Maybe<
    DeviceProfileUpdateOneRequiredWithoutDeviceNetworkTypeLinksInput
  >;
  networkSettings?: Maybe<String>;
}

export interface DeviceCreateManyWithoutApplicationInput {
  create?: Maybe<
    DeviceCreateWithoutApplicationInput[] | DeviceCreateWithoutApplicationInput
  >;
  connect?: Maybe<DeviceWhereUniqueInput[] | DeviceWhereUniqueInput>;
}

export interface DeviceNetworkTypeLinkUpdateManyMutationInput {
  networkSettings?: Maybe<String>;
}

export interface NetworkTypeCreateOneWithoutNetworksInput {
  create?: Maybe<NetworkTypeCreateWithoutNetworksInput>;
  connect?: Maybe<NetworkTypeWhereUniqueInput>;
}

export interface DeviceProfileCreateInput {
  networkType: NetworkTypeCreateOneWithoutDeviceProfilesInput;
  company: CompanyCreateOneWithoutDeviceProfilesInput;
  name?: Maybe<String>;
  description?: Maybe<String>;
  networkSettings?: Maybe<String>;
  deviceNetworkTypeLinks?: Maybe<
    DeviceNetworkTypeLinkCreateManyWithoutDeviceProfileInput
  >;
}

export interface ApplicationUpdateInput {
  company?: Maybe<CompanyUpdateOneWithoutApplicationsInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  baseUrl?: Maybe<String>;
  enabled?: Maybe<Boolean>;
  reportingProtocol?: Maybe<ReportingProtocolUpdateOneWithoutApplicationsInput>;
  applicationNetworkTypeLinks?: Maybe<
    ApplicationNetworkTypeLinkUpdateManyWithoutApplicationInput
  >;
  devices?: Maybe<DeviceUpdateManyWithoutApplicationInput>;
}

export interface DeviceProfileUpdateInput {
  networkType?: Maybe<NetworkTypeUpdateOneRequiredWithoutDeviceProfilesInput>;
  company?: Maybe<CompanyUpdateOneRequiredWithoutDeviceProfilesInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  networkSettings?: Maybe<String>;
  deviceNetworkTypeLinks?: Maybe<
    DeviceNetworkTypeLinkUpdateManyWithoutDeviceProfileInput
  >;
}

export interface UserCreateManyWithoutRoleInput {
  create?: Maybe<UserCreateWithoutRoleInput[] | UserCreateWithoutRoleInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserCreateWithoutEmailVerificationsInput {
  username?: Maybe<String>;
  email?: Maybe<String>;
  lastVerifiedEmail?: Maybe<String>;
  emailVerified?: Maybe<Boolean>;
  company: CompanyCreateOneWithoutUsersInput;
  passwordHash: String;
  role: UserRoleCreateOneWithoutUsersInput;
}

export interface UserCreateOneWithoutEmailVerificationsInput {
  create?: Maybe<UserCreateWithoutEmailVerificationsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface EmailVerificationCreateInput {
  user: UserCreateOneWithoutEmailVerificationsInput;
  uuid?: Maybe<String>;
  email?: Maybe<String>;
  changeRequested?: Maybe<String>;
}

export interface DeviceProfileUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  networkSettings?: Maybe<String>;
}

export interface DeviceNetworkTypeLinkCreateManyWithoutNetworkTypeInput {
  create?: Maybe<
    | DeviceNetworkTypeLinkCreateWithoutNetworkTypeInput[]
    | DeviceNetworkTypeLinkCreateWithoutNetworkTypeInput
  >;
  connect?: Maybe<
    | DeviceNetworkTypeLinkWhereUniqueInput[]
    | DeviceNetworkTypeLinkWhereUniqueInput
  >;
}

export interface CompanyWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  type?: Maybe<CompanyTypeWhereInput>;
  applications_every?: Maybe<ApplicationWhereInput>;
  applications_some?: Maybe<ApplicationWhereInput>;
  applications_none?: Maybe<ApplicationWhereInput>;
  companyNetworkTypeLinks_every?: Maybe<CompanyNetworkTypeLinkWhereInput>;
  companyNetworkTypeLinks_some?: Maybe<CompanyNetworkTypeLinkWhereInput>;
  companyNetworkTypeLinks_none?: Maybe<CompanyNetworkTypeLinkWhereInput>;
  deviceProfiles_every?: Maybe<DeviceProfileWhereInput>;
  deviceProfiles_some?: Maybe<DeviceProfileWhereInput>;
  deviceProfiles_none?: Maybe<DeviceProfileWhereInput>;
  passwordPolicies_every?: Maybe<PasswordPolicyWhereInput>;
  passwordPolicies_some?: Maybe<PasswordPolicyWhereInput>;
  passwordPolicies_none?: Maybe<PasswordPolicyWhereInput>;
  users_every?: Maybe<UserWhereInput>;
  users_some?: Maybe<UserWhereInput>;
  users_none?: Maybe<UserWhereInput>;
  AND?: Maybe<CompanyWhereInput[] | CompanyWhereInput>;
  OR?: Maybe<CompanyWhereInput[] | CompanyWhereInput>;
  NOT?: Maybe<CompanyWhereInput[] | CompanyWhereInput>;
}

export interface ProtocolDataSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProtocolDataWhereInput>;
  AND?: Maybe<
    ProtocolDataSubscriptionWhereInput[] | ProtocolDataSubscriptionWhereInput
  >;
  OR?: Maybe<
    ProtocolDataSubscriptionWhereInput[] | ProtocolDataSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ProtocolDataSubscriptionWhereInput[] | ProtocolDataSubscriptionWhereInput
  >;
}

export interface ProtocolDataCreateManyWithoutNetworkInput {
  create?: Maybe<
    | ProtocolDataCreateWithoutNetworkInput[]
    | ProtocolDataCreateWithoutNetworkInput
  >;
  connect?: Maybe<
    ProtocolDataWhereUniqueInput[] | ProtocolDataWhereUniqueInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserRolePreviousValues {
  id: Int;
  name?: String;
}

export interface UserRolePreviousValuesPromise
  extends Promise<UserRolePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
}

export interface UserRolePreviousValuesSubscription
  extends Promise<AsyncIterator<UserRolePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface ApplicationNetworkTypeLinkEdge {
  node: ApplicationNetworkTypeLink;
  cursor: String;
}

export interface ApplicationNetworkTypeLinkEdgePromise
  extends Promise<ApplicationNetworkTypeLinkEdge>,
    Fragmentable {
  node: <T = ApplicationNetworkTypeLinkPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ApplicationNetworkTypeLinkEdgeSubscription
  extends Promise<AsyncIterator<ApplicationNetworkTypeLinkEdge>>,
    Fragmentable {
  node: <T = ApplicationNetworkTypeLinkSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface NetworkType {
  id: Int;
  name: String;
}

export interface NetworkTypePromise extends Promise<NetworkType>, Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
  applicationNetworkTypeLinks: <
    T = FragmentableArray<ApplicationNetworkTypeLink>
  >(args?: {
    where?: ApplicationNetworkTypeLinkWhereInput;
    orderBy?: ApplicationNetworkTypeLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  companyNetworkTypeLinks: <
    T = FragmentableArray<CompanyNetworkTypeLink>
  >(args?: {
    where?: CompanyNetworkTypeLinkWhereInput;
    orderBy?: CompanyNetworkTypeLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  deviceNetworkTypeLinks: <
    T = FragmentableArray<DeviceNetworkTypeLink>
  >(args?: {
    where?: DeviceNetworkTypeLinkWhereInput;
    orderBy?: DeviceNetworkTypeLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  deviceProfiles: <T = FragmentableArray<DeviceProfile>>(args?: {
    where?: DeviceProfileWhereInput;
    orderBy?: DeviceProfileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  networkProtocols: <T = FragmentableArray<NetworkProtocol>>(args?: {
    where?: NetworkProtocolWhereInput;
    orderBy?: NetworkProtocolOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  networks: <T = FragmentableArray<Network>>(args?: {
    where?: NetworkWhereInput;
    orderBy?: NetworkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface NetworkTypeSubscription
  extends Promise<AsyncIterator<NetworkType>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  applicationNetworkTypeLinks: <
    T = Promise<AsyncIterator<ApplicationNetworkTypeLinkSubscription>>
  >(args?: {
    where?: ApplicationNetworkTypeLinkWhereInput;
    orderBy?: ApplicationNetworkTypeLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  companyNetworkTypeLinks: <
    T = Promise<AsyncIterator<CompanyNetworkTypeLinkSubscription>>
  >(args?: {
    where?: CompanyNetworkTypeLinkWhereInput;
    orderBy?: CompanyNetworkTypeLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  deviceNetworkTypeLinks: <
    T = Promise<AsyncIterator<DeviceNetworkTypeLinkSubscription>>
  >(args?: {
    where?: DeviceNetworkTypeLinkWhereInput;
    orderBy?: DeviceNetworkTypeLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  deviceProfiles: <
    T = Promise<AsyncIterator<DeviceProfileSubscription>>
  >(args?: {
    where?: DeviceProfileWhereInput;
    orderBy?: DeviceProfileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  networkProtocols: <
    T = Promise<AsyncIterator<NetworkProtocolSubscription>>
  >(args?: {
    where?: NetworkProtocolWhereInput;
    orderBy?: NetworkProtocolOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  networks: <T = Promise<AsyncIterator<NetworkSubscription>>>(args?: {
    where?: NetworkWhereInput;
    orderBy?: NetworkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface NetworkTypeNullablePromise
  extends Promise<NetworkType | null>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
  applicationNetworkTypeLinks: <
    T = FragmentableArray<ApplicationNetworkTypeLink>
  >(args?: {
    where?: ApplicationNetworkTypeLinkWhereInput;
    orderBy?: ApplicationNetworkTypeLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  companyNetworkTypeLinks: <
    T = FragmentableArray<CompanyNetworkTypeLink>
  >(args?: {
    where?: CompanyNetworkTypeLinkWhereInput;
    orderBy?: CompanyNetworkTypeLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  deviceNetworkTypeLinks: <
    T = FragmentableArray<DeviceNetworkTypeLink>
  >(args?: {
    where?: DeviceNetworkTypeLinkWhereInput;
    orderBy?: DeviceNetworkTypeLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  deviceProfiles: <T = FragmentableArray<DeviceProfile>>(args?: {
    where?: DeviceProfileWhereInput;
    orderBy?: DeviceProfileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  networkProtocols: <T = FragmentableArray<NetworkProtocol>>(args?: {
    where?: NetworkProtocolWhereInput;
    orderBy?: NetworkProtocolOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  networks: <T = FragmentableArray<Network>>(args?: {
    where?: NetworkWhereInput;
    orderBy?: NetworkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ApplicationNetworkTypeLinkConnection {
  pageInfo: PageInfo;
  edges: ApplicationNetworkTypeLinkEdge[];
}

export interface ApplicationNetworkTypeLinkConnectionPromise
  extends Promise<ApplicationNetworkTypeLinkConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ApplicationNetworkTypeLinkEdge>>() => T;
  aggregate: <T = AggregateApplicationNetworkTypeLinkPromise>() => T;
}

export interface ApplicationNetworkTypeLinkConnectionSubscription
  extends Promise<AsyncIterator<ApplicationNetworkTypeLinkConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ApplicationNetworkTypeLinkEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateApplicationNetworkTypeLinkSubscription>() => T;
}

export interface CompanyNetworkTypeLink {
  id: Int;
  networkSettings?: String;
}

export interface CompanyNetworkTypeLinkPromise
  extends Promise<CompanyNetworkTypeLink>,
    Fragmentable {
  id: () => Promise<Int>;
  company: <T = CompanyPromise>() => T;
  networkType: <T = NetworkTypePromise>() => T;
  networkSettings: () => Promise<String>;
}

export interface CompanyNetworkTypeLinkSubscription
  extends Promise<AsyncIterator<CompanyNetworkTypeLink>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  company: <T = CompanySubscription>() => T;
  networkType: <T = NetworkTypeSubscription>() => T;
  networkSettings: () => Promise<AsyncIterator<String>>;
}

export interface CompanyNetworkTypeLinkNullablePromise
  extends Promise<CompanyNetworkTypeLink | null>,
    Fragmentable {
  id: () => Promise<Int>;
  company: <T = CompanyPromise>() => T;
  networkType: <T = NetworkTypePromise>() => T;
  networkSettings: () => Promise<String>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface ApplicationNetworkTypeLink {
  id: Int;
  networkSettings?: String;
}

export interface ApplicationNetworkTypeLinkPromise
  extends Promise<ApplicationNetworkTypeLink>,
    Fragmentable {
  id: () => Promise<Int>;
  application: <T = ApplicationPromise>() => T;
  networkType: <T = NetworkTypePromise>() => T;
  networkSettings: () => Promise<String>;
}

export interface ApplicationNetworkTypeLinkSubscription
  extends Promise<AsyncIterator<ApplicationNetworkTypeLink>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  application: <T = ApplicationSubscription>() => T;
  networkType: <T = NetworkTypeSubscription>() => T;
  networkSettings: () => Promise<AsyncIterator<String>>;
}

export interface ApplicationNetworkTypeLinkNullablePromise
  extends Promise<ApplicationNetworkTypeLink | null>,
    Fragmentable {
  id: () => Promise<Int>;
  application: <T = ApplicationPromise>() => T;
  networkType: <T = NetworkTypePromise>() => T;
  networkSettings: () => Promise<String>;
}

export interface AggregateApplication {
  count: Int;
}

export interface AggregateApplicationPromise
  extends Promise<AggregateApplication>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateApplicationSubscription
  extends Promise<AsyncIterator<AggregateApplication>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateUserRole {
  count: Int;
}

export interface AggregateUserRolePromise
  extends Promise<AggregateUserRole>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserRoleSubscription
  extends Promise<AsyncIterator<AggregateUserRole>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserRoleConnection {
  pageInfo: PageInfo;
  edges: UserRoleEdge[];
}

export interface UserRoleConnectionPromise
  extends Promise<UserRoleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserRoleEdge>>() => T;
  aggregate: <T = AggregateUserRolePromise>() => T;
}

export interface UserRoleConnectionSubscription
  extends Promise<AsyncIterator<UserRoleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserRoleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserRoleSubscription>() => T;
}

export interface Application {
  id: Int;
  name?: String;
  description?: String;
  baseUrl?: String;
  enabled?: Boolean;
}

export interface ApplicationPromise extends Promise<Application>, Fragmentable {
  id: () => Promise<Int>;
  company: <T = CompanyPromise>() => T;
  name: () => Promise<String>;
  description: () => Promise<String>;
  baseUrl: () => Promise<String>;
  enabled: () => Promise<Boolean>;
  reportingProtocol: <T = ReportingProtocolPromise>() => T;
  applicationNetworkTypeLinks: <
    T = FragmentableArray<ApplicationNetworkTypeLink>
  >(args?: {
    where?: ApplicationNetworkTypeLinkWhereInput;
    orderBy?: ApplicationNetworkTypeLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  devices: <T = FragmentableArray<Device>>(args?: {
    where?: DeviceWhereInput;
    orderBy?: DeviceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ApplicationSubscription
  extends Promise<AsyncIterator<Application>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  company: <T = CompanySubscription>() => T;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  baseUrl: () => Promise<AsyncIterator<String>>;
  enabled: () => Promise<AsyncIterator<Boolean>>;
  reportingProtocol: <T = ReportingProtocolSubscription>() => T;
  applicationNetworkTypeLinks: <
    T = Promise<AsyncIterator<ApplicationNetworkTypeLinkSubscription>>
  >(args?: {
    where?: ApplicationNetworkTypeLinkWhereInput;
    orderBy?: ApplicationNetworkTypeLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  devices: <T = Promise<AsyncIterator<DeviceSubscription>>>(args?: {
    where?: DeviceWhereInput;
    orderBy?: DeviceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ApplicationNullablePromise
  extends Promise<Application | null>,
    Fragmentable {
  id: () => Promise<Int>;
  company: <T = CompanyPromise>() => T;
  name: () => Promise<String>;
  description: () => Promise<String>;
  baseUrl: () => Promise<String>;
  enabled: () => Promise<Boolean>;
  reportingProtocol: <T = ReportingProtocolPromise>() => T;
  applicationNetworkTypeLinks: <
    T = FragmentableArray<ApplicationNetworkTypeLink>
  >(args?: {
    where?: ApplicationNetworkTypeLinkWhereInput;
    orderBy?: ApplicationNetworkTypeLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  devices: <T = FragmentableArray<Device>>(args?: {
    where?: DeviceWhereInput;
    orderBy?: DeviceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ApplicationSubscriptionPayload {
  mutation: MutationType;
  node: Application;
  updatedFields: String[];
  previousValues: ApplicationPreviousValues;
}

export interface ApplicationSubscriptionPayloadPromise
  extends Promise<ApplicationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ApplicationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ApplicationPreviousValuesPromise>() => T;
}

export interface ApplicationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ApplicationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ApplicationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ApplicationPreviousValuesSubscription>() => T;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface ApplicationPreviousValues {
  id: Int;
  name?: String;
  description?: String;
  baseUrl?: String;
  enabled?: Boolean;
}

export interface ApplicationPreviousValuesPromise
  extends Promise<ApplicationPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  baseUrl: () => Promise<String>;
  enabled: () => Promise<Boolean>;
}

export interface ApplicationPreviousValuesSubscription
  extends Promise<AsyncIterator<ApplicationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  baseUrl: () => Promise<AsyncIterator<String>>;
  enabled: () => Promise<AsyncIterator<Boolean>>;
}

export interface ReportingProtocolEdge {
  node: ReportingProtocol;
  cursor: String;
}

export interface ReportingProtocolEdgePromise
  extends Promise<ReportingProtocolEdge>,
    Fragmentable {
  node: <T = ReportingProtocolPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ReportingProtocolEdgeSubscription
  extends Promise<AsyncIterator<ReportingProtocolEdge>>,
    Fragmentable {
  node: <T = ReportingProtocolSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ApplicationEdge {
  node: Application;
  cursor: String;
}

export interface ApplicationEdgePromise
  extends Promise<ApplicationEdge>,
    Fragmentable {
  node: <T = ApplicationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ApplicationEdgeSubscription
  extends Promise<AsyncIterator<ApplicationEdge>>,
    Fragmentable {
  node: <T = ApplicationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserRoleSubscriptionPayload {
  mutation: MutationType;
  node: UserRole;
  updatedFields: String[];
  previousValues: UserRolePreviousValues;
}

export interface UserRoleSubscriptionPayloadPromise
  extends Promise<UserRoleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserRolePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserRolePreviousValuesPromise>() => T;
}

export interface UserRoleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserRoleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserRoleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserRolePreviousValuesSubscription>() => T;
}

export interface ApplicationNetworkTypeLinkSubscriptionPayload {
  mutation: MutationType;
  node: ApplicationNetworkTypeLink;
  updatedFields: String[];
  previousValues: ApplicationNetworkTypeLinkPreviousValues;
}

export interface ApplicationNetworkTypeLinkSubscriptionPayloadPromise
  extends Promise<ApplicationNetworkTypeLinkSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ApplicationNetworkTypeLinkPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ApplicationNetworkTypeLinkPreviousValuesPromise>() => T;
}

export interface ApplicationNetworkTypeLinkSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ApplicationNetworkTypeLinkSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ApplicationNetworkTypeLinkSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = ApplicationNetworkTypeLinkPreviousValuesSubscription
  >() => T;
}

export interface ProtocolDataEdge {
  node: ProtocolData;
  cursor: String;
}

export interface ProtocolDataEdgePromise
  extends Promise<ProtocolDataEdge>,
    Fragmentable {
  node: <T = ProtocolDataPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProtocolDataEdgeSubscription
  extends Promise<AsyncIterator<ProtocolDataEdge>>,
    Fragmentable {
  node: <T = ProtocolDataSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ApplicationNetworkTypeLinkPreviousValues {
  id: Int;
  networkSettings?: String;
}

export interface ApplicationNetworkTypeLinkPreviousValuesPromise
  extends Promise<ApplicationNetworkTypeLinkPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  networkSettings: () => Promise<String>;
}

export interface ApplicationNetworkTypeLinkPreviousValuesSubscription
  extends Promise<AsyncIterator<ApplicationNetworkTypeLinkPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  networkSettings: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePasswordPolicy {
  count: Int;
}

export interface AggregatePasswordPolicyPromise
  extends Promise<AggregatePasswordPolicy>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePasswordPolicySubscription
  extends Promise<AsyncIterator<AggregatePasswordPolicy>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface PasswordPolicyConnection {
  pageInfo: PageInfo;
  edges: PasswordPolicyEdge[];
}

export interface PasswordPolicyConnectionPromise
  extends Promise<PasswordPolicyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PasswordPolicyEdge>>() => T;
  aggregate: <T = AggregatePasswordPolicyPromise>() => T;
}

export interface PasswordPolicyConnectionSubscription
  extends Promise<AsyncIterator<PasswordPolicyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PasswordPolicyEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePasswordPolicySubscription>() => T;
}

export interface CompanySubscriptionPayload {
  mutation: MutationType;
  node: Company;
  updatedFields: String[];
  previousValues: CompanyPreviousValues;
}

export interface CompanySubscriptionPayloadPromise
  extends Promise<CompanySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CompanyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CompanyPreviousValuesPromise>() => T;
}

export interface CompanySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CompanySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CompanySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CompanyPreviousValuesSubscription>() => T;
}

export interface NetworkTypeEdge {
  node: NetworkType;
  cursor: String;
}

export interface NetworkTypeEdgePromise
  extends Promise<NetworkTypeEdge>,
    Fragmentable {
  node: <T = NetworkTypePromise>() => T;
  cursor: () => Promise<String>;
}

export interface NetworkTypeEdgeSubscription
  extends Promise<AsyncIterator<NetworkTypeEdge>>,
    Fragmentable {
  node: <T = NetworkTypeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CompanyPreviousValues {
  id: Int;
  name?: String;
}

export interface CompanyPreviousValuesPromise
  extends Promise<CompanyPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
}

export interface CompanyPreviousValuesSubscription
  extends Promise<AsyncIterator<CompanyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface CompanyType {
  id: Int;
  name?: String;
}

export interface CompanyTypePromise extends Promise<CompanyType>, Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
  companies: <T = FragmentableArray<Company>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CompanyTypeSubscription
  extends Promise<AsyncIterator<CompanyType>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  companies: <T = Promise<AsyncIterator<CompanySubscription>>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CompanyTypeNullablePromise
  extends Promise<CompanyType | null>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
  companies: <T = FragmentableArray<Company>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ApplicationConnection {
  pageInfo: PageInfo;
  edges: ApplicationEdge[];
}

export interface ApplicationConnectionPromise
  extends Promise<ApplicationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ApplicationEdge>>() => T;
  aggregate: <T = AggregateApplicationPromise>() => T;
}

export interface ApplicationConnectionSubscription
  extends Promise<AsyncIterator<ApplicationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ApplicationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateApplicationSubscription>() => T;
}

export interface NetworkProviderEdge {
  node: NetworkProvider;
  cursor: String;
}

export interface NetworkProviderEdgePromise
  extends Promise<NetworkProviderEdge>,
    Fragmentable {
  node: <T = NetworkProviderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface NetworkProviderEdgeSubscription
  extends Promise<AsyncIterator<NetworkProviderEdge>>,
    Fragmentable {
  node: <T = NetworkProviderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CompanyNetworkTypeLinkSubscriptionPayload {
  mutation: MutationType;
  node: CompanyNetworkTypeLink;
  updatedFields: String[];
  previousValues: CompanyNetworkTypeLinkPreviousValues;
}

export interface CompanyNetworkTypeLinkSubscriptionPayloadPromise
  extends Promise<CompanyNetworkTypeLinkSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CompanyNetworkTypeLinkPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CompanyNetworkTypeLinkPreviousValuesPromise>() => T;
}

export interface CompanyNetworkTypeLinkSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CompanyNetworkTypeLinkSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CompanyNetworkTypeLinkSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CompanyNetworkTypeLinkPreviousValuesSubscription>() => T;
}

export interface AggregateNetworkProtocol {
  count: Int;
}

export interface AggregateNetworkProtocolPromise
  extends Promise<AggregateNetworkProtocol>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNetworkProtocolSubscription
  extends Promise<AsyncIterator<AggregateNetworkProtocol>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CompanyNetworkTypeLinkPreviousValues {
  id: Int;
  networkSettings?: String;
}

export interface CompanyNetworkTypeLinkPreviousValuesPromise
  extends Promise<CompanyNetworkTypeLinkPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  networkSettings: () => Promise<String>;
}

export interface CompanyNetworkTypeLinkPreviousValuesSubscription
  extends Promise<AsyncIterator<CompanyNetworkTypeLinkPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  networkSettings: () => Promise<AsyncIterator<String>>;
}

export interface NetworkProtocolConnection {
  pageInfo: PageInfo;
  edges: NetworkProtocolEdge[];
}

export interface NetworkProtocolConnectionPromise
  extends Promise<NetworkProtocolConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NetworkProtocolEdge>>() => T;
  aggregate: <T = AggregateNetworkProtocolPromise>() => T;
}

export interface NetworkProtocolConnectionSubscription
  extends Promise<AsyncIterator<NetworkProtocolConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NetworkProtocolEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNetworkProtocolSubscription>() => T;
}

export interface ReportingProtocol {
  id: Int;
  name?: String;
  protocolHandler?: String;
}

export interface ReportingProtocolPromise
  extends Promise<ReportingProtocol>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
  protocolHandler: () => Promise<String>;
  applications: <T = FragmentableArray<Application>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ReportingProtocolSubscription
  extends Promise<AsyncIterator<ReportingProtocol>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  protocolHandler: () => Promise<AsyncIterator<String>>;
  applications: <T = Promise<AsyncIterator<ApplicationSubscription>>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ReportingProtocolNullablePromise
  extends Promise<ReportingProtocol | null>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
  protocolHandler: () => Promise<String>;
  applications: <T = FragmentableArray<Application>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface NetworkEdge {
  node: Network;
  cursor: String;
}

export interface NetworkEdgePromise extends Promise<NetworkEdge>, Fragmentable {
  node: <T = NetworkPromise>() => T;
  cursor: () => Promise<String>;
}

export interface NetworkEdgeSubscription
  extends Promise<AsyncIterator<NetworkEdge>>,
    Fragmentable {
  node: <T = NetworkSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CompanyTypeSubscriptionPayload {
  mutation: MutationType;
  node: CompanyType;
  updatedFields: String[];
  previousValues: CompanyTypePreviousValues;
}

export interface CompanyTypeSubscriptionPayloadPromise
  extends Promise<CompanyTypeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CompanyTypePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CompanyTypePreviousValuesPromise>() => T;
}

export interface CompanyTypeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CompanyTypeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CompanyTypeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CompanyTypePreviousValuesSubscription>() => T;
}

export interface AggregateEmailVerification {
  count: Int;
}

export interface AggregateEmailVerificationPromise
  extends Promise<AggregateEmailVerification>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEmailVerificationSubscription
  extends Promise<AsyncIterator<AggregateEmailVerification>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CompanyTypePreviousValues {
  id: Int;
  name?: String;
}

export interface CompanyTypePreviousValuesPromise
  extends Promise<CompanyTypePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
}

export interface CompanyTypePreviousValuesSubscription
  extends Promise<AsyncIterator<CompanyTypePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface EmailVerificationConnection {
  pageInfo: PageInfo;
  edges: EmailVerificationEdge[];
}

export interface EmailVerificationConnectionPromise
  extends Promise<EmailVerificationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EmailVerificationEdge>>() => T;
  aggregate: <T = AggregateEmailVerificationPromise>() => T;
}

export interface EmailVerificationConnectionSubscription
  extends Promise<AsyncIterator<EmailVerificationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EmailVerificationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEmailVerificationSubscription>() => T;
}

export interface EmailVerification {
  id: Int;
  uuid?: String;
  email?: String;
  changeRequested?: String;
}

export interface EmailVerificationPromise
  extends Promise<EmailVerification>,
    Fragmentable {
  id: () => Promise<Int>;
  user: <T = UserPromise>() => T;
  uuid: () => Promise<String>;
  email: () => Promise<String>;
  changeRequested: () => Promise<String>;
}

export interface EmailVerificationSubscription
  extends Promise<AsyncIterator<EmailVerification>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  user: <T = UserSubscription>() => T;
  uuid: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  changeRequested: () => Promise<AsyncIterator<String>>;
}

export interface EmailVerificationNullablePromise
  extends Promise<EmailVerification | null>,
    Fragmentable {
  id: () => Promise<Int>;
  user: <T = UserPromise>() => T;
  uuid: () => Promise<String>;
  email: () => Promise<String>;
  changeRequested: () => Promise<String>;
}

export interface DeviceProfileEdge {
  node: DeviceProfile;
  cursor: String;
}

export interface DeviceProfileEdgePromise
  extends Promise<DeviceProfileEdge>,
    Fragmentable {
  node: <T = DeviceProfilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface DeviceProfileEdgeSubscription
  extends Promise<AsyncIterator<DeviceProfileEdge>>,
    Fragmentable {
  node: <T = DeviceProfileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DeviceSubscriptionPayload {
  mutation: MutationType;
  node: Device;
  updatedFields: String[];
  previousValues: DevicePreviousValues;
}

export interface DeviceSubscriptionPayloadPromise
  extends Promise<DeviceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DevicePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DevicePreviousValuesPromise>() => T;
}

export interface DeviceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DeviceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DeviceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DevicePreviousValuesSubscription>() => T;
}

export interface AggregateDeviceNetworkTypeLink {
  count: Int;
}

export interface AggregateDeviceNetworkTypeLinkPromise
  extends Promise<AggregateDeviceNetworkTypeLink>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDeviceNetworkTypeLinkSubscription
  extends Promise<AsyncIterator<AggregateDeviceNetworkTypeLink>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DevicePreviousValues {
  id: Int;
  name?: String;
  description?: String;
  deviceModel?: String;
}

export interface DevicePreviousValuesPromise
  extends Promise<DevicePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  deviceModel: () => Promise<String>;
}

export interface DevicePreviousValuesSubscription
  extends Promise<AsyncIterator<DevicePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  deviceModel: () => Promise<AsyncIterator<String>>;
}

export interface DeviceNetworkTypeLinkConnection {
  pageInfo: PageInfo;
  edges: DeviceNetworkTypeLinkEdge[];
}

export interface DeviceNetworkTypeLinkConnectionPromise
  extends Promise<DeviceNetworkTypeLinkConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DeviceNetworkTypeLinkEdge>>() => T;
  aggregate: <T = AggregateDeviceNetworkTypeLinkPromise>() => T;
}

export interface DeviceNetworkTypeLinkConnectionSubscription
  extends Promise<AsyncIterator<DeviceNetworkTypeLinkConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<DeviceNetworkTypeLinkEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateDeviceNetworkTypeLinkSubscription>() => T;
}

export interface UserPreviousValues {
  id: Int;
  username?: String;
  email?: String;
  lastVerifiedEmail?: String;
  emailVerified?: Boolean;
  passwordHash: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  username: () => Promise<String>;
  email: () => Promise<String>;
  lastVerifiedEmail: () => Promise<String>;
  emailVerified: () => Promise<Boolean>;
  passwordHash: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  username: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  lastVerifiedEmail: () => Promise<AsyncIterator<String>>;
  emailVerified: () => Promise<AsyncIterator<Boolean>>;
  passwordHash: () => Promise<AsyncIterator<String>>;
}

export interface DeviceEdge {
  node: Device;
  cursor: String;
}

export interface DeviceEdgePromise extends Promise<DeviceEdge>, Fragmentable {
  node: <T = DevicePromise>() => T;
  cursor: () => Promise<String>;
}

export interface DeviceEdgeSubscription
  extends Promise<AsyncIterator<DeviceEdge>>,
    Fragmentable {
  node: <T = DeviceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DeviceNetworkTypeLinkSubscriptionPayload {
  mutation: MutationType;
  node: DeviceNetworkTypeLink;
  updatedFields: String[];
  previousValues: DeviceNetworkTypeLinkPreviousValues;
}

export interface DeviceNetworkTypeLinkSubscriptionPayloadPromise
  extends Promise<DeviceNetworkTypeLinkSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DeviceNetworkTypeLinkPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DeviceNetworkTypeLinkPreviousValuesPromise>() => T;
}

export interface DeviceNetworkTypeLinkSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DeviceNetworkTypeLinkSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DeviceNetworkTypeLinkSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DeviceNetworkTypeLinkPreviousValuesSubscription>() => T;
}

export interface AggregateCompanyType {
  count: Int;
}

export interface AggregateCompanyTypePromise
  extends Promise<AggregateCompanyType>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCompanyTypeSubscription
  extends Promise<AsyncIterator<AggregateCompanyType>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DeviceNetworkTypeLinkPreviousValues {
  id: Int;
  networkSettings?: String;
}

export interface DeviceNetworkTypeLinkPreviousValuesPromise
  extends Promise<DeviceNetworkTypeLinkPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  networkSettings: () => Promise<String>;
}

export interface DeviceNetworkTypeLinkPreviousValuesSubscription
  extends Promise<AsyncIterator<DeviceNetworkTypeLinkPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  networkSettings: () => Promise<AsyncIterator<String>>;
}

export interface CompanyTypeConnection {
  pageInfo: PageInfo;
  edges: CompanyTypeEdge[];
}

export interface CompanyTypeConnectionPromise
  extends Promise<CompanyTypeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CompanyTypeEdge>>() => T;
  aggregate: <T = AggregateCompanyTypePromise>() => T;
}

export interface CompanyTypeConnectionSubscription
  extends Promise<AsyncIterator<CompanyTypeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CompanyTypeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCompanyTypeSubscription>() => T;
}

export interface UserRole {
  id: Int;
  name?: String;
}

export interface UserRolePromise extends Promise<UserRole>, Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
  users: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserRoleSubscription
  extends Promise<AsyncIterator<UserRole>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  users: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserRoleNullablePromise
  extends Promise<UserRole | null>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
  users: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CompanyNetworkTypeLinkEdge {
  node: CompanyNetworkTypeLink;
  cursor: String;
}

export interface CompanyNetworkTypeLinkEdgePromise
  extends Promise<CompanyNetworkTypeLinkEdge>,
    Fragmentable {
  node: <T = CompanyNetworkTypeLinkPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CompanyNetworkTypeLinkEdgeSubscription
  extends Promise<AsyncIterator<CompanyNetworkTypeLinkEdge>>,
    Fragmentable {
  node: <T = CompanyNetworkTypeLinkSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DeviceProfileSubscriptionPayload {
  mutation: MutationType;
  node: DeviceProfile;
  updatedFields: String[];
  previousValues: DeviceProfilePreviousValues;
}

export interface DeviceProfileSubscriptionPayloadPromise
  extends Promise<DeviceProfileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DeviceProfilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DeviceProfilePreviousValuesPromise>() => T;
}

export interface DeviceProfileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DeviceProfileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DeviceProfileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DeviceProfilePreviousValuesSubscription>() => T;
}

export interface AggregateCompany {
  count: Int;
}

export interface AggregateCompanyPromise
  extends Promise<AggregateCompany>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCompanySubscription
  extends Promise<AsyncIterator<AggregateCompany>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DeviceProfilePreviousValues {
  id: Int;
  name?: String;
  description?: String;
  networkSettings?: String;
}

export interface DeviceProfilePreviousValuesPromise
  extends Promise<DeviceProfilePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  networkSettings: () => Promise<String>;
}

export interface DeviceProfilePreviousValuesSubscription
  extends Promise<AsyncIterator<DeviceProfilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  networkSettings: () => Promise<AsyncIterator<String>>;
}

export interface CompanyConnection {
  pageInfo: PageInfo;
  edges: CompanyEdge[];
}

export interface CompanyConnectionPromise
  extends Promise<CompanyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CompanyEdge>>() => T;
  aggregate: <T = AggregateCompanyPromise>() => T;
}

export interface CompanyConnectionSubscription
  extends Promise<AsyncIterator<CompanyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CompanyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCompanySubscription>() => T;
}

export interface User {
  id: Int;
  username?: String;
  email?: String;
  lastVerifiedEmail?: String;
  emailVerified?: Boolean;
  passwordHash: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<Int>;
  username: () => Promise<String>;
  email: () => Promise<String>;
  lastVerifiedEmail: () => Promise<String>;
  emailVerified: () => Promise<Boolean>;
  company: <T = CompanyPromise>() => T;
  passwordHash: () => Promise<String>;
  role: <T = UserRolePromise>() => T;
  emailVerifications: <T = FragmentableArray<EmailVerification>>(args?: {
    where?: EmailVerificationWhereInput;
    orderBy?: EmailVerificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  username: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  lastVerifiedEmail: () => Promise<AsyncIterator<String>>;
  emailVerified: () => Promise<AsyncIterator<Boolean>>;
  company: <T = CompanySubscription>() => T;
  passwordHash: () => Promise<AsyncIterator<String>>;
  role: <T = UserRoleSubscription>() => T;
  emailVerifications: <
    T = Promise<AsyncIterator<EmailVerificationSubscription>>
  >(args?: {
    where?: EmailVerificationWhereInput;
    orderBy?: EmailVerificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<Int>;
  username: () => Promise<String>;
  email: () => Promise<String>;
  lastVerifiedEmail: () => Promise<String>;
  emailVerified: () => Promise<Boolean>;
  company: <T = CompanyPromise>() => T;
  passwordHash: () => Promise<String>;
  role: <T = UserRolePromise>() => T;
  emailVerifications: <T = FragmentableArray<EmailVerification>>(args?: {
    where?: EmailVerificationWhereInput;
    orderBy?: EmailVerificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserRoleEdge {
  node: UserRole;
  cursor: String;
}

export interface UserRoleEdgePromise
  extends Promise<UserRoleEdge>,
    Fragmentable {
  node: <T = UserRolePromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserRoleEdgeSubscription
  extends Promise<AsyncIterator<UserRoleEdge>>,
    Fragmentable {
  node: <T = UserRoleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface EmailVerificationSubscriptionPayload {
  mutation: MutationType;
  node: EmailVerification;
  updatedFields: String[];
  previousValues: EmailVerificationPreviousValues;
}

export interface EmailVerificationSubscriptionPayloadPromise
  extends Promise<EmailVerificationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EmailVerificationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EmailVerificationPreviousValuesPromise>() => T;
}

export interface EmailVerificationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EmailVerificationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EmailVerificationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EmailVerificationPreviousValuesSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface EmailVerificationPreviousValues {
  id: Int;
  uuid?: String;
  email?: String;
  changeRequested?: String;
}

export interface EmailVerificationPreviousValuesPromise
  extends Promise<EmailVerificationPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  uuid: () => Promise<String>;
  email: () => Promise<String>;
  changeRequested: () => Promise<String>;
}

export interface EmailVerificationPreviousValuesSubscription
  extends Promise<AsyncIterator<EmailVerificationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  uuid: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  changeRequested: () => Promise<AsyncIterator<String>>;
}

export interface ReportingProtocolConnection {
  pageInfo: PageInfo;
  edges: ReportingProtocolEdge[];
}

export interface ReportingProtocolConnectionPromise
  extends Promise<ReportingProtocolConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ReportingProtocolEdge>>() => T;
  aggregate: <T = AggregateReportingProtocolPromise>() => T;
}

export interface ReportingProtocolConnectionSubscription
  extends Promise<AsyncIterator<ReportingProtocolConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ReportingProtocolEdgeSubscription>>>() => T;
  aggregate: <T = AggregateReportingProtocolSubscription>() => T;
}

export interface PasswordPolicy {
  id: Int;
  ruleText?: String;
  ruleRegExp?: String;
}

export interface PasswordPolicyPromise
  extends Promise<PasswordPolicy>,
    Fragmentable {
  id: () => Promise<Int>;
  ruleText: () => Promise<String>;
  ruleRegExp: () => Promise<String>;
  company: <T = CompanyPromise>() => T;
}

export interface PasswordPolicySubscription
  extends Promise<AsyncIterator<PasswordPolicy>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  ruleText: () => Promise<AsyncIterator<String>>;
  ruleRegExp: () => Promise<AsyncIterator<String>>;
  company: <T = CompanySubscription>() => T;
}

export interface PasswordPolicyNullablePromise
  extends Promise<PasswordPolicy | null>,
    Fragmentable {
  id: () => Promise<Int>;
  ruleText: () => Promise<String>;
  ruleRegExp: () => Promise<String>;
  company: <T = CompanyPromise>() => T;
}

export interface ProtocolDataConnection {
  pageInfo: PageInfo;
  edges: ProtocolDataEdge[];
}

export interface ProtocolDataConnectionPromise
  extends Promise<ProtocolDataConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProtocolDataEdge>>() => T;
  aggregate: <T = AggregateProtocolDataPromise>() => T;
}

export interface ProtocolDataConnectionSubscription
  extends Promise<AsyncIterator<ProtocolDataConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProtocolDataEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProtocolDataSubscription>() => T;
}

export interface NetworkSubscriptionPayload {
  mutation: MutationType;
  node: Network;
  updatedFields: String[];
  previousValues: NetworkPreviousValues;
}

export interface NetworkSubscriptionPayloadPromise
  extends Promise<NetworkSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NetworkPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NetworkPreviousValuesPromise>() => T;
}

export interface NetworkSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NetworkSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NetworkSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NetworkPreviousValuesSubscription>() => T;
}

export interface AggregateNetworkType {
  count: Int;
}

export interface AggregateNetworkTypePromise
  extends Promise<AggregateNetworkType>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNetworkTypeSubscription
  extends Promise<AsyncIterator<AggregateNetworkType>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NetworkPreviousValues {
  id: Int;
  name?: String;
  baseUrl?: String;
  securityData?: String;
}

export interface NetworkPreviousValuesPromise
  extends Promise<NetworkPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
  baseUrl: () => Promise<String>;
  securityData: () => Promise<String>;
}

export interface NetworkPreviousValuesSubscription
  extends Promise<AsyncIterator<NetworkPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  baseUrl: () => Promise<AsyncIterator<String>>;
  securityData: () => Promise<AsyncIterator<String>>;
}

export interface AggregateNetworkProvider {
  count: Int;
}

export interface AggregateNetworkProviderPromise
  extends Promise<AggregateNetworkProvider>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNetworkProviderSubscription
  extends Promise<AsyncIterator<AggregateNetworkProvider>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProtocolData {
  id: Int;
  dataIdentifier?: String;
  dataValue?: String;
}

export interface ProtocolDataPromise
  extends Promise<ProtocolData>,
    Fragmentable {
  id: () => Promise<Int>;
  network: <T = NetworkPromise>() => T;
  networkProtocol: <T = NetworkProtocolPromise>() => T;
  dataIdentifier: () => Promise<String>;
  dataValue: () => Promise<String>;
}

export interface ProtocolDataSubscription
  extends Promise<AsyncIterator<ProtocolData>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  network: <T = NetworkSubscription>() => T;
  networkProtocol: <T = NetworkProtocolSubscription>() => T;
  dataIdentifier: () => Promise<AsyncIterator<String>>;
  dataValue: () => Promise<AsyncIterator<String>>;
}

export interface ProtocolDataNullablePromise
  extends Promise<ProtocolData | null>,
    Fragmentable {
  id: () => Promise<Int>;
  network: <T = NetworkPromise>() => T;
  networkProtocol: <T = NetworkProtocolPromise>() => T;
  dataIdentifier: () => Promise<String>;
  dataValue: () => Promise<String>;
}

export interface NetworkProtocolEdge {
  node: NetworkProtocol;
  cursor: String;
}

export interface NetworkProtocolEdgePromise
  extends Promise<NetworkProtocolEdge>,
    Fragmentable {
  node: <T = NetworkProtocolPromise>() => T;
  cursor: () => Promise<String>;
}

export interface NetworkProtocolEdgeSubscription
  extends Promise<AsyncIterator<NetworkProtocolEdge>>,
    Fragmentable {
  node: <T = NetworkProtocolSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface NetworkProtocolSubscriptionPayload {
  mutation: MutationType;
  node: NetworkProtocol;
  updatedFields: String[];
  previousValues: NetworkProtocolPreviousValues;
}

export interface NetworkProtocolSubscriptionPayloadPromise
  extends Promise<NetworkProtocolSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NetworkProtocolPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NetworkProtocolPreviousValuesPromise>() => T;
}

export interface NetworkProtocolSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NetworkProtocolSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NetworkProtocolSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NetworkProtocolPreviousValuesSubscription>() => T;
}

export interface NetworkConnection {
  pageInfo: PageInfo;
  edges: NetworkEdge[];
}

export interface NetworkConnectionPromise
  extends Promise<NetworkConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NetworkEdge>>() => T;
  aggregate: <T = AggregateNetworkPromise>() => T;
}

export interface NetworkConnectionSubscription
  extends Promise<AsyncIterator<NetworkConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NetworkEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNetworkSubscription>() => T;
}

export interface NetworkProtocolPreviousValues {
  id: Int;
  name?: String;
  protocolHandler?: String;
  networkProtocolVersion?: String;
  masterProtocol?: Int;
}

export interface NetworkProtocolPreviousValuesPromise
  extends Promise<NetworkProtocolPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
  protocolHandler: () => Promise<String>;
  networkProtocolVersion: () => Promise<String>;
  masterProtocol: () => Promise<Int>;
}

export interface NetworkProtocolPreviousValuesSubscription
  extends Promise<AsyncIterator<NetworkProtocolPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  protocolHandler: () => Promise<AsyncIterator<String>>;
  networkProtocolVersion: () => Promise<AsyncIterator<String>>;
  masterProtocol: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateDeviceProfile {
  count: Int;
}

export interface AggregateDeviceProfilePromise
  extends Promise<AggregateDeviceProfile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDeviceProfileSubscription
  extends Promise<AsyncIterator<AggregateDeviceProfile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NetworkProvider {
  id: Int;
  name?: String;
}

export interface NetworkProviderPromise
  extends Promise<NetworkProvider>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
  networks: <T = FragmentableArray<Network>>(args?: {
    where?: NetworkWhereInput;
    orderBy?: NetworkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface NetworkProviderSubscription
  extends Promise<AsyncIterator<NetworkProvider>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  networks: <T = Promise<AsyncIterator<NetworkSubscription>>>(args?: {
    where?: NetworkWhereInput;
    orderBy?: NetworkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface NetworkProviderNullablePromise
  extends Promise<NetworkProvider | null>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
  networks: <T = FragmentableArray<Network>>(args?: {
    where?: NetworkWhereInput;
    orderBy?: NetworkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DeviceNetworkTypeLinkEdge {
  node: DeviceNetworkTypeLink;
  cursor: String;
}

export interface DeviceNetworkTypeLinkEdgePromise
  extends Promise<DeviceNetworkTypeLinkEdge>,
    Fragmentable {
  node: <T = DeviceNetworkTypeLinkPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DeviceNetworkTypeLinkEdgeSubscription
  extends Promise<AsyncIterator<DeviceNetworkTypeLinkEdge>>,
    Fragmentable {
  node: <T = DeviceNetworkTypeLinkSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface NetworkProviderSubscriptionPayload {
  mutation: MutationType;
  node: NetworkProvider;
  updatedFields: String[];
  previousValues: NetworkProviderPreviousValues;
}

export interface NetworkProviderSubscriptionPayloadPromise
  extends Promise<NetworkProviderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NetworkProviderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NetworkProviderPreviousValuesPromise>() => T;
}

export interface NetworkProviderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NetworkProviderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NetworkProviderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NetworkProviderPreviousValuesSubscription>() => T;
}

export interface DeviceConnection {
  pageInfo: PageInfo;
  edges: DeviceEdge[];
}

export interface DeviceConnectionPromise
  extends Promise<DeviceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DeviceEdge>>() => T;
  aggregate: <T = AggregateDevicePromise>() => T;
}

export interface DeviceConnectionSubscription
  extends Promise<AsyncIterator<DeviceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DeviceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDeviceSubscription>() => T;
}

export interface NetworkProviderPreviousValues {
  id: Int;
  name?: String;
}

export interface NetworkProviderPreviousValuesPromise
  extends Promise<NetworkProviderPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
}

export interface NetworkProviderPreviousValuesSubscription
  extends Promise<AsyncIterator<NetworkProviderPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCompanyNetworkTypeLink {
  count: Int;
}

export interface AggregateCompanyNetworkTypeLinkPromise
  extends Promise<AggregateCompanyNetworkTypeLink>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCompanyNetworkTypeLinkSubscription
  extends Promise<AsyncIterator<AggregateCompanyNetworkTypeLink>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Network {
  id: Int;
  name?: String;
  baseUrl?: String;
  securityData?: String;
}

export interface NetworkPromise extends Promise<Network>, Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
  networkProvider: <T = NetworkProviderPromise>() => T;
  networkType: <T = NetworkTypePromise>() => T;
  networkProtocol: <T = NetworkProtocolPromise>() => T;
  baseUrl: () => Promise<String>;
  securityData: () => Promise<String>;
  protocolData: <T = FragmentableArray<ProtocolData>>(args?: {
    where?: ProtocolDataWhereInput;
    orderBy?: ProtocolDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface NetworkSubscription
  extends Promise<AsyncIterator<Network>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  networkProvider: <T = NetworkProviderSubscription>() => T;
  networkType: <T = NetworkTypeSubscription>() => T;
  networkProtocol: <T = NetworkProtocolSubscription>() => T;
  baseUrl: () => Promise<AsyncIterator<String>>;
  securityData: () => Promise<AsyncIterator<String>>;
  protocolData: <T = Promise<AsyncIterator<ProtocolDataSubscription>>>(args?: {
    where?: ProtocolDataWhereInput;
    orderBy?: ProtocolDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface NetworkNullablePromise
  extends Promise<Network | null>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
  networkProvider: <T = NetworkProviderPromise>() => T;
  networkType: <T = NetworkTypePromise>() => T;
  networkProtocol: <T = NetworkProtocolPromise>() => T;
  baseUrl: () => Promise<String>;
  securityData: () => Promise<String>;
  protocolData: <T = FragmentableArray<ProtocolData>>(args?: {
    where?: ProtocolDataWhereInput;
    orderBy?: ProtocolDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CompanyEdge {
  node: Company;
  cursor: String;
}

export interface CompanyEdgePromise extends Promise<CompanyEdge>, Fragmentable {
  node: <T = CompanyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CompanyEdgeSubscription
  extends Promise<AsyncIterator<CompanyEdge>>,
    Fragmentable {
  node: <T = CompanySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface NetworkTypeSubscriptionPayload {
  mutation: MutationType;
  node: NetworkType;
  updatedFields: String[];
  previousValues: NetworkTypePreviousValues;
}

export interface NetworkTypeSubscriptionPayloadPromise
  extends Promise<NetworkTypeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NetworkTypePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NetworkTypePreviousValuesPromise>() => T;
}

export interface NetworkTypeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NetworkTypeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NetworkTypeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NetworkTypePreviousValuesSubscription>() => T;
}

export interface Company {
  id: Int;
  name?: String;
}

export interface CompanyPromise extends Promise<Company>, Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
  type: <T = CompanyTypePromise>() => T;
  applications: <T = FragmentableArray<Application>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  companyNetworkTypeLinks: <
    T = FragmentableArray<CompanyNetworkTypeLink>
  >(args?: {
    where?: CompanyNetworkTypeLinkWhereInput;
    orderBy?: CompanyNetworkTypeLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  deviceProfiles: <T = FragmentableArray<DeviceProfile>>(args?: {
    where?: DeviceProfileWhereInput;
    orderBy?: DeviceProfileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  passwordPolicies: <T = FragmentableArray<PasswordPolicy>>(args?: {
    where?: PasswordPolicyWhereInput;
    orderBy?: PasswordPolicyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  users: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CompanySubscription
  extends Promise<AsyncIterator<Company>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  type: <T = CompanyTypeSubscription>() => T;
  applications: <T = Promise<AsyncIterator<ApplicationSubscription>>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  companyNetworkTypeLinks: <
    T = Promise<AsyncIterator<CompanyNetworkTypeLinkSubscription>>
  >(args?: {
    where?: CompanyNetworkTypeLinkWhereInput;
    orderBy?: CompanyNetworkTypeLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  deviceProfiles: <
    T = Promise<AsyncIterator<DeviceProfileSubscription>>
  >(args?: {
    where?: DeviceProfileWhereInput;
    orderBy?: DeviceProfileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  passwordPolicies: <
    T = Promise<AsyncIterator<PasswordPolicySubscription>>
  >(args?: {
    where?: PasswordPolicyWhereInput;
    orderBy?: PasswordPolicyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  users: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CompanyNullablePromise
  extends Promise<Company | null>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
  type: <T = CompanyTypePromise>() => T;
  applications: <T = FragmentableArray<Application>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  companyNetworkTypeLinks: <
    T = FragmentableArray<CompanyNetworkTypeLink>
  >(args?: {
    where?: CompanyNetworkTypeLinkWhereInput;
    orderBy?: CompanyNetworkTypeLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  deviceProfiles: <T = FragmentableArray<DeviceProfile>>(args?: {
    where?: DeviceProfileWhereInput;
    orderBy?: DeviceProfileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  passwordPolicies: <T = FragmentableArray<PasswordPolicy>>(args?: {
    where?: PasswordPolicyWhereInput;
    orderBy?: PasswordPolicyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  users: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface NetworkTypePreviousValues {
  id: Int;
  name: String;
}

export interface NetworkTypePreviousValuesPromise
  extends Promise<NetworkTypePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
}

export interface NetworkTypePreviousValuesSubscription
  extends Promise<AsyncIterator<NetworkTypePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProtocolData {
  count: Int;
}

export interface AggregateProtocolDataPromise
  extends Promise<AggregateProtocolData>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProtocolDataSubscription
  extends Promise<AsyncIterator<AggregateProtocolData>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NetworkProtocol {
  id: Int;
  name?: String;
  protocolHandler?: String;
  networkProtocolVersion?: String;
  masterProtocol?: Int;
}

export interface NetworkProtocolPromise
  extends Promise<NetworkProtocol>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
  protocolHandler: () => Promise<String>;
  networkType: <T = NetworkTypePromise>() => T;
  networkProtocolVersion: () => Promise<String>;
  masterProtocol: () => Promise<Int>;
  networks: <T = FragmentableArray<Network>>(args?: {
    where?: NetworkWhereInput;
    orderBy?: NetworkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  protocolData: <T = FragmentableArray<ProtocolData>>(args?: {
    where?: ProtocolDataWhereInput;
    orderBy?: ProtocolDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface NetworkProtocolSubscription
  extends Promise<AsyncIterator<NetworkProtocol>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  protocolHandler: () => Promise<AsyncIterator<String>>;
  networkType: <T = NetworkTypeSubscription>() => T;
  networkProtocolVersion: () => Promise<AsyncIterator<String>>;
  masterProtocol: () => Promise<AsyncIterator<Int>>;
  networks: <T = Promise<AsyncIterator<NetworkSubscription>>>(args?: {
    where?: NetworkWhereInput;
    orderBy?: NetworkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  protocolData: <T = Promise<AsyncIterator<ProtocolDataSubscription>>>(args?: {
    where?: ProtocolDataWhereInput;
    orderBy?: ProtocolDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface NetworkProtocolNullablePromise
  extends Promise<NetworkProtocol | null>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
  protocolHandler: () => Promise<String>;
  networkType: <T = NetworkTypePromise>() => T;
  networkProtocolVersion: () => Promise<String>;
  masterProtocol: () => Promise<Int>;
  networks: <T = FragmentableArray<Network>>(args?: {
    where?: NetworkWhereInput;
    orderBy?: NetworkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  protocolData: <T = FragmentableArray<ProtocolData>>(args?: {
    where?: ProtocolDataWhereInput;
    orderBy?: ProtocolDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface NetworkTypeConnection {
  pageInfo: PageInfo;
  edges: NetworkTypeEdge[];
}

export interface NetworkTypeConnectionPromise
  extends Promise<NetworkTypeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NetworkTypeEdge>>() => T;
  aggregate: <T = AggregateNetworkTypePromise>() => T;
}

export interface NetworkTypeConnectionSubscription
  extends Promise<AsyncIterator<NetworkTypeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NetworkTypeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNetworkTypeSubscription>() => T;
}

export interface PasswordPolicySubscriptionPayload {
  mutation: MutationType;
  node: PasswordPolicy;
  updatedFields: String[];
  previousValues: PasswordPolicyPreviousValues;
}

export interface PasswordPolicySubscriptionPayloadPromise
  extends Promise<PasswordPolicySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PasswordPolicyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PasswordPolicyPreviousValuesPromise>() => T;
}

export interface PasswordPolicySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PasswordPolicySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PasswordPolicySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PasswordPolicyPreviousValuesSubscription>() => T;
}

export interface AggregateNetwork {
  count: Int;
}

export interface AggregateNetworkPromise
  extends Promise<AggregateNetwork>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNetworkSubscription
  extends Promise<AsyncIterator<AggregateNetwork>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PasswordPolicyPreviousValues {
  id: Int;
  ruleText?: String;
  ruleRegExp?: String;
}

export interface PasswordPolicyPreviousValuesPromise
  extends Promise<PasswordPolicyPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  ruleText: () => Promise<String>;
  ruleRegExp: () => Promise<String>;
}

export interface PasswordPolicyPreviousValuesSubscription
  extends Promise<AsyncIterator<PasswordPolicyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  ruleText: () => Promise<AsyncIterator<String>>;
  ruleRegExp: () => Promise<AsyncIterator<String>>;
}

export interface DeviceProfileConnection {
  pageInfo: PageInfo;
  edges: DeviceProfileEdge[];
}

export interface DeviceProfileConnectionPromise
  extends Promise<DeviceProfileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DeviceProfileEdge>>() => T;
  aggregate: <T = AggregateDeviceProfilePromise>() => T;
}

export interface DeviceProfileConnectionSubscription
  extends Promise<AsyncIterator<DeviceProfileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DeviceProfileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDeviceProfileSubscription>() => T;
}

export interface DeviceProfile {
  id: Int;
  name?: String;
  description?: String;
  networkSettings?: String;
}

export interface DeviceProfilePromise
  extends Promise<DeviceProfile>,
    Fragmentable {
  id: () => Promise<Int>;
  networkType: <T = NetworkTypePromise>() => T;
  company: <T = CompanyPromise>() => T;
  name: () => Promise<String>;
  description: () => Promise<String>;
  networkSettings: () => Promise<String>;
  deviceNetworkTypeLinks: <
    T = FragmentableArray<DeviceNetworkTypeLink>
  >(args?: {
    where?: DeviceNetworkTypeLinkWhereInput;
    orderBy?: DeviceNetworkTypeLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DeviceProfileSubscription
  extends Promise<AsyncIterator<DeviceProfile>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  networkType: <T = NetworkTypeSubscription>() => T;
  company: <T = CompanySubscription>() => T;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  networkSettings: () => Promise<AsyncIterator<String>>;
  deviceNetworkTypeLinks: <
    T = Promise<AsyncIterator<DeviceNetworkTypeLinkSubscription>>
  >(args?: {
    where?: DeviceNetworkTypeLinkWhereInput;
    orderBy?: DeviceNetworkTypeLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DeviceProfileNullablePromise
  extends Promise<DeviceProfile | null>,
    Fragmentable {
  id: () => Promise<Int>;
  networkType: <T = NetworkTypePromise>() => T;
  company: <T = CompanyPromise>() => T;
  name: () => Promise<String>;
  description: () => Promise<String>;
  networkSettings: () => Promise<String>;
  deviceNetworkTypeLinks: <
    T = FragmentableArray<DeviceNetworkTypeLink>
  >(args?: {
    where?: DeviceNetworkTypeLinkWhereInput;
    orderBy?: DeviceNetworkTypeLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CompanyTypeEdge {
  node: CompanyType;
  cursor: String;
}

export interface CompanyTypeEdgePromise
  extends Promise<CompanyTypeEdge>,
    Fragmentable {
  node: <T = CompanyTypePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CompanyTypeEdgeSubscription
  extends Promise<AsyncIterator<CompanyTypeEdge>>,
    Fragmentable {
  node: <T = CompanyTypeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProtocolDataSubscriptionPayload {
  mutation: MutationType;
  node: ProtocolData;
  updatedFields: String[];
  previousValues: ProtocolDataPreviousValues;
}

export interface ProtocolDataSubscriptionPayloadPromise
  extends Promise<ProtocolDataSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProtocolDataPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProtocolDataPreviousValuesPromise>() => T;
}

export interface ProtocolDataSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProtocolDataSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProtocolDataSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProtocolDataPreviousValuesSubscription>() => T;
}

export interface AggregateApplicationNetworkTypeLink {
  count: Int;
}

export interface AggregateApplicationNetworkTypeLinkPromise
  extends Promise<AggregateApplicationNetworkTypeLink>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateApplicationNetworkTypeLinkSubscription
  extends Promise<AsyncIterator<AggregateApplicationNetworkTypeLink>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProtocolDataPreviousValues {
  id: Int;
  dataIdentifier?: String;
  dataValue?: String;
}

export interface ProtocolDataPreviousValuesPromise
  extends Promise<ProtocolDataPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  dataIdentifier: () => Promise<String>;
  dataValue: () => Promise<String>;
}

export interface ProtocolDataPreviousValuesSubscription
  extends Promise<AsyncIterator<ProtocolDataPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  dataIdentifier: () => Promise<AsyncIterator<String>>;
  dataValue: () => Promise<AsyncIterator<String>>;
}

export interface PasswordPolicyEdge {
  node: PasswordPolicy;
  cursor: String;
}

export interface PasswordPolicyEdgePromise
  extends Promise<PasswordPolicyEdge>,
    Fragmentable {
  node: <T = PasswordPolicyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PasswordPolicyEdgeSubscription
  extends Promise<AsyncIterator<PasswordPolicyEdge>>,
    Fragmentable {
  node: <T = PasswordPolicySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface EmailVerificationEdge {
  node: EmailVerification;
  cursor: String;
}

export interface EmailVerificationEdgePromise
  extends Promise<EmailVerificationEdge>,
    Fragmentable {
  node: <T = EmailVerificationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EmailVerificationEdgeSubscription
  extends Promise<AsyncIterator<EmailVerificationEdge>>,
    Fragmentable {
  node: <T = EmailVerificationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DeviceNetworkTypeLink {
  id: Int;
  networkSettings?: String;
}

export interface DeviceNetworkTypeLinkPromise
  extends Promise<DeviceNetworkTypeLink>,
    Fragmentable {
  id: () => Promise<Int>;
  device: <T = DevicePromise>() => T;
  networkType: <T = NetworkTypePromise>() => T;
  deviceProfile: <T = DeviceProfilePromise>() => T;
  networkSettings: () => Promise<String>;
}

export interface DeviceNetworkTypeLinkSubscription
  extends Promise<AsyncIterator<DeviceNetworkTypeLink>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  device: <T = DeviceSubscription>() => T;
  networkType: <T = NetworkTypeSubscription>() => T;
  deviceProfile: <T = DeviceProfileSubscription>() => T;
  networkSettings: () => Promise<AsyncIterator<String>>;
}

export interface DeviceNetworkTypeLinkNullablePromise
  extends Promise<DeviceNetworkTypeLink | null>,
    Fragmentable {
  id: () => Promise<Int>;
  device: <T = DevicePromise>() => T;
  networkType: <T = NetworkTypePromise>() => T;
  deviceProfile: <T = DeviceProfilePromise>() => T;
  networkSettings: () => Promise<String>;
}

export interface ReportingProtocolPreviousValues {
  id: Int;
  name?: String;
  protocolHandler?: String;
}

export interface ReportingProtocolPreviousValuesPromise
  extends Promise<ReportingProtocolPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
  protocolHandler: () => Promise<String>;
}

export interface ReportingProtocolPreviousValuesSubscription
  extends Promise<AsyncIterator<ReportingProtocolPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  protocolHandler: () => Promise<AsyncIterator<String>>;
}

export interface ReportingProtocolSubscriptionPayload {
  mutation: MutationType;
  node: ReportingProtocol;
  updatedFields: String[];
  previousValues: ReportingProtocolPreviousValues;
}

export interface ReportingProtocolSubscriptionPayloadPromise
  extends Promise<ReportingProtocolSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ReportingProtocolPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ReportingProtocolPreviousValuesPromise>() => T;
}

export interface ReportingProtocolSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ReportingProtocolSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ReportingProtocolSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ReportingProtocolPreviousValuesSubscription>() => T;
}

export interface Device {
  id: Int;
  name?: String;
  description?: String;
  deviceModel?: String;
}

export interface DevicePromise extends Promise<Device>, Fragmentable {
  id: () => Promise<Int>;
  application: <T = ApplicationPromise>() => T;
  name: () => Promise<String>;
  description: () => Promise<String>;
  deviceModel: () => Promise<String>;
  deviceNetworkTypeLinks: <
    T = FragmentableArray<DeviceNetworkTypeLink>
  >(args?: {
    where?: DeviceNetworkTypeLinkWhereInput;
    orderBy?: DeviceNetworkTypeLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DeviceSubscription
  extends Promise<AsyncIterator<Device>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  application: <T = ApplicationSubscription>() => T;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  deviceModel: () => Promise<AsyncIterator<String>>;
  deviceNetworkTypeLinks: <
    T = Promise<AsyncIterator<DeviceNetworkTypeLinkSubscription>>
  >(args?: {
    where?: DeviceNetworkTypeLinkWhereInput;
    orderBy?: DeviceNetworkTypeLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DeviceNullablePromise
  extends Promise<Device | null>,
    Fragmentable {
  id: () => Promise<Int>;
  application: <T = ApplicationPromise>() => T;
  name: () => Promise<String>;
  description: () => Promise<String>;
  deviceModel: () => Promise<String>;
  deviceNetworkTypeLinks: <
    T = FragmentableArray<DeviceNetworkTypeLink>
  >(args?: {
    where?: DeviceNetworkTypeLinkWhereInput;
    orderBy?: DeviceNetworkTypeLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AggregateDevice {
  count: Int;
}

export interface AggregateDevicePromise
  extends Promise<AggregateDevice>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDeviceSubscription
  extends Promise<AsyncIterator<AggregateDevice>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NetworkProviderConnection {
  pageInfo: PageInfo;
  edges: NetworkProviderEdge[];
}

export interface NetworkProviderConnectionPromise
  extends Promise<NetworkProviderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NetworkProviderEdge>>() => T;
  aggregate: <T = AggregateNetworkProviderPromise>() => T;
}

export interface NetworkProviderConnectionSubscription
  extends Promise<AsyncIterator<NetworkProviderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NetworkProviderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNetworkProviderSubscription>() => T;
}

export interface AggregateReportingProtocol {
  count: Int;
}

export interface AggregateReportingProtocolPromise
  extends Promise<AggregateReportingProtocol>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateReportingProtocolSubscription
  extends Promise<AsyncIterator<AggregateReportingProtocol>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CompanyNetworkTypeLinkConnection {
  pageInfo: PageInfo;
  edges: CompanyNetworkTypeLinkEdge[];
}

export interface CompanyNetworkTypeLinkConnectionPromise
  extends Promise<CompanyNetworkTypeLinkConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CompanyNetworkTypeLinkEdge>>() => T;
  aggregate: <T = AggregateCompanyNetworkTypeLinkPromise>() => T;
}

export interface CompanyNetworkTypeLinkConnectionSubscription
  extends Promise<AsyncIterator<CompanyNetworkTypeLinkConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<CompanyNetworkTypeLinkEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateCompanyNetworkTypeLinkSubscription>() => T;
}

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "DeviceNetworkTypeLink",
    embedded: false
  },
  {
    name: "Application",
    embedded: false
  },
  {
    name: "Company",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "NetworkType",
    embedded: false
  },
  {
    name: "ApplicationNetworkTypeLink",
    embedded: false
  },
  {
    name: "ReportingProtocol",
    embedded: false
  },
  {
    name: "ProtocolData",
    embedded: false
  },
  {
    name: "UserRole",
    embedded: false
  },
  {
    name: "Network",
    embedded: false
  },
  {
    name: "PasswordPolicy",
    embedded: false
  },
  {
    name: "NetworkProtocol",
    embedded: false
  },
  {
    name: "NetworkProvider",
    embedded: false
  },
  {
    name: "Device",
    embedded: false
  },
  {
    name: "DeviceProfile",
    embedded: false
  },
  {
    name: "CompanyNetworkTypeLink",
    embedded: false
  },
  {
    name: "CompanyType",
    embedded: false
  },
  {
    name: "EmailVerification",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
